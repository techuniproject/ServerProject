#include <iostream>
#include <thread>
#include <chrono>
#include <vector>
//using namespace std;

//========================  [ CPU 스케줄링 ] ======================================//
																																																																																																											/*
	1)	[ CPU 스케줄링 개요 ]
    
	- 스케줄링은 자원에 대한 경쟁이 있을 때 경쟁자들 중 하나를 선택하는 과정으로 컴퓨터 시스템 여러 곳에서 일어난다
	- CPU 스케줄링은 준비 상태에 있는 스레드들 중 하나를 선택하여 CPU를 할당하는 과정.

	 1. 다중 프로그래밍(초창기 운체)과 스케줄링
	  - 다중 프로그래밍은 CPU의 유후(idle) 시간을 줄이기 위해 도입되었다.
	  - 정의) 여러개의 프로그램을 메모리에 동시에 적재해두고, 운영체제는 프로세스가 I/O 작업을 요청하면 프로세스를 중단시키고 
				다른 프로세스에게 CPU를 넘겨 CPU의 유후 시간을 줄였다. 
	  - 다중 프로그래밍이 도입된 이후 운영체제는 작업 스케줄링과 CPU 스케줄링을 시행하였다.
	   [1] 작업 스케줄링 : 메모리에 적재된 프로세스가 종료하면, 디스크나 큐에 대기 중인 작업 중에서 어떤 작업을 메모리에 올려 실행할지 결정하는.
	   [2] CPU 스케줄링  : 현재 메모리에 올라가 있는 여러 프로세스 및 스레드 중 누구에게 CPU를 줄지 결정하는 것.

	 2. CPU burst와 I/O burst
	  - 일반적으로 응용프로그램에서는 CPU의 연산 작업뿐 아니라, 화면 출력, 키보드 입력, 파일 입출력, 네트워크 송수신 등
	     I/O 작업이 섞여 있다.
	  - 그러므로 응용프로그램(프로세스) 이 실행되는 과정은 한동안 CPU에 의해 코드가 실행되다가, 화면에 출력하거나 하는 I/O가 진행되고,
	     I/O가 완료되면 다시 CPU의 연산 작업이 실행되기를 반복한다.
	  [1] CPU BURST : 프로그램의 실행 과정에서 CPU가 코드를 집중적으로 실행하는 상황.
	  [2] I/O BURST : I/O 장치에 의해 입출력이 이루어지는 상황.

	 * I/O burst 시간 동안 CPU 유휴 시간을 줄이기 위해 CPU를 다른 프로세스에게 할당하는 CPU 스케줄링이 도입됨.

	  [1] CPU Intensive Process : CPU burst time > I/O burst Time
	  [2] I/O Intensive Process : I/O burst time > CPU burst Time

	 3. CPU 스케줄링의 기본 목표
	  - CPU 스케줄링은 실행을 기다리는 스레드 중 하나를 선택하는 과정으로 기본 목표는 
	   [1] CPU 활용률 향상 (CPU가 놀지 않게 하는)
	   [2] 컴퓨터 시스템 처리율 향상 ( 시간 단위당 더 많은 스레드 처리)

	 4. CPU 스케줄링의 기준(criteria) - 컴퓨터 시스템마다 다름
	  
	  [1] CPU 활용률 (CPU utilization) 
		 -> CPU활용률은 컴퓨터 전체 가동 시간에 대한 CPU 사용 시간의 비율이다. 높아야 좋음.

	  [2] 처리율 (throughput)
	     -> 처리율은 단위 시간 당 처리하는 스레드의 개수.

	  [3] 공평성 (fairness)
		 -> 모든 스레드에게 CPU 사용 시간을 공평하게 배분하는 것이 스케줄링 목표가 되기도 함.

	  [4] 응답 시간 (response time)
	     -> 사용자에 대한 응답 시간 최소화가 스케줄링 목표나 평가 기준이 되기도 함.

	  [5] 대기 시간 (waiting time)
	     -> 대기 시간은 스레드가 준비 리스트에서 CPU 할당받을 때까지 기다리는 시간으로
		     이를 최소화하는 것이 스케줄링의 목표나 평가 기준이 되기도 함.

	  [6] 소요 시간 (turnaround time)
	     -> 소요 시간이란 작업이 컴퓨터 시스템에 진입하는 시점에서 완료까지 걸리는 시간이다.
		 
		 [배치 시스템] : 여러 작업을 모아 순차적으로 하나씩 실행
		  -> 배치 시스템에서는 작업이 제출된 시점부터 결과가 반환될 때까지 걸린 시간이고.
		 
		 [다중 프로그래밍 시스템] : 여러 프로그램을 동시에 메모리에 적재하여 바꿔가며 실행.
		  -> 다중 프로그래밍 시스템에서는 프로세스가 시작되어 종료될 때까지 걸린 시간이다.

		 - 사용자 입장에서, 소요 시간은 작업을 시작시킨 사용자가 결과를 얻기까지 걸린 총 시간.

	  [7] 시스템 정책 우선 (high policy enforcement)
	     -> 시스템 정책 우선이란 CPU 스케줄링이 시스템의 정책에 맞도록 이루어져야함을 뜻함.
		 -> 특정 목적의 시스템에서 다른 스레드보다 특정 목적을 담당하는 스레드의 우선순위가 높아야함.

	  [8] 자원 활용률 (high resource efficiency)
	     -> CPU나 I/O 장치 등 자원이 놀지 않도록 자원 활용률을 극대화하는 것이 스케줄링 목표가 되기도 함.
		 -> 자원 활용률이 높아지면 단위 시간당 더 많은 작업을 처리 가능하기 때문.

	 5. CPU 스케줄링의 타임 슬라이스 (Time Slice) 
	  [타임 슬라이스 or 타임 퀀텀]
	  - 운영체제는 스레드가 CPU를 사용할 타임 슬라이스를 정하고 이 시간 동안만 CPU를 사용하게 한다.
	  
	  -> 가장 높은 순위의 스레드에게 무조건 CPU를 할당하는 철저한 우선순위 기반 운영체제를 제외하고,
	      대부분의 운영체제들은 하나의 스레드가 너무 오래 CPU를 사용하도록 허용하지 않는다.
	  -> 커널은 타이머의 도움을 받아 타임 슬라이스가 되면 스레드를 강제 중단시켜(preemption) 준비 리스트에 
	      삽입하고 다른 스레드를 선택하여 타임 슬라이스 동안 CPU를 사용하도록 한다.
	  -> 타임 슬라이스는 스레드가 CPU 사용을 보장받는 시간이며 커널이 CPU 스케줄링을 하는 주기 시간이다.
	  -> 컨텍스트 스위칭에 걸리는 시간이 몇십 나노초~ 몇 마이크로 초이므로 타임 슬라이스는 이보다 길어야 의미있다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	2)	[ CPU 스케줄링 기본 ]
	   - CPU 스케줄링이 실행되는 상황 대체적 4가지
	 
	 [1] 스레드가 I/O를 요청하는 시스템 호출을 실행하여 블록 상태가 되거나 자원을 기다리는 상태가 될 때
	      -> 다른 스레드에게 CPU를 할당하는 경우
	 
	 [2] 스레드가 자발적으로 CPU를 반환하는 경우
	      -> 스레드가 yield() 시스템 호출을 통해 스스로 실행을 중단하고 CPU를 자발적으로 내놓을 때
		      현재 스레드를 준비 상태로 만들어 준비 리스트에 넣고 CPU 스케줄링을 시행한다.

     [3] 스레드에게 할당된 타임 슬라이스가 다 소진되어 타이머 인터럽트가 발생할 때 인터럽트 서비스 루틴 내에서 CPU 스케줄링이 실행됨.

	 [4] 현재 실행중인 스레드보다 더 높은 순위의 스레드가 요청한 입출력 작업이 완료되어 I/O 인터럽트가 발생한 경우,
	      인터럽트 서비스 루틴에서 현재 스레드를 강제로 중단시켜 중비 상태로 만들고 I/O를 기다렸던 더 높은 스레드를 스케줄링하여 실행.


    === 1. [CPU 스케줄링과 디스패치] ===

	  [CPU 스케줄링 코드의 위치와 실행 시점]
	   - CPU 스케줄링은 커널에 의해 이루어진다.
	 
		[1] CPU 스케줄링을 담당하는 별도의 커널 스레드나 프로세스가 있는가? -> X
		 - 거의 모든 현대 운영체제는 스케줄링을 전담하는 별도의 스레드가 없고 스케줄링 코드는 시스템 호출이나
		     인터럽트 서비스 루틴에 의해 호출되는 코드(함수) 형태로 존재한다.
		
		[2] CPU 스케줄링 코드가 실행되는 자세한 시점은 언젠가?
		 - CPU 스케줄링 코드는 시스템 호출이나 인터럽트 서비스 루티닝 서비스를 마치는 마지막 과정에서 스케줄링이 필요할 때 호출됨.

	   [디스패처 코드 실행] - 스케줄러 코드와 마찬가지로 실행 시간이 짧아야 좋음 
	    - 디스패처 코드는 스케줄러 코드에 의해 선택된 스레드를 CPU가 실행하도록 하는 커널 코드의 한 부분이다.
		- 디스패처 코드는 현재 CPU 레지스터들을 스레드 A의 TCB-A에 저장하고, 스레드 B의 TCB-B에 저장된 레지스터들을
	       CPU에 적재하는 컨텍스트 스위칭을 실행한다.
		


	===	2.	[ CPU 스케줄링 타입 : 선점 스케줄링과 비선점 스케줄링 ] ===
		   - CPU 스케줄링은 실행 중인 스레드를 강제로 중단시키는지 여부에 따라 비선점 스케줄링과 선점 스케줄링으로 나뉜다.

		   [1] 비선점 스케줄링 (Non-preemptive scheduling)
		    - 비선점 스케줄링은 스레드가 CPU를 할당받아 일단 실행을 시작하면 완료되거나 CPU를 더 이상 사용할 수 없는 상황이 
			   될 때까지 스레드를 중간에 강제 중단시키지 않고, 실행중인 스레드가 더 이상 CPU를 사용할 수 없는 상황에야 스케줄링을 시행.
		    [실행중인 스레드가 더이상 CPU 사용못하는 경우]
			- I/O로 인한 블록 상태, sleep()
			- 자발적 CPU 양보 : yield() 시스템 호출
			- 스레드 종료
			
			-> 현재는 거의 사용하지 않는다. 
			-> 비선점 스케줄링에 속하는 알고리즘 SRTF(Shortest Remaining Time First), Priority(non-preemptive version)
		
		   [2] 선점 스케줄링
		    - 선점 스케줄링은 현재 실행 중인 스레드를 강제로 중단시켜 준비 리스트로 이동시키고 스케줄링하는 방식이다.
			[선점 스케줄링을 채택하는 스케줄링 알고리즘은 대체로 다음의 상황에서 강제로 스케줄링한다]
			 - 타음 슬라이스가 소진되었을 때
			 - 인터럽트나 시스템 호출 종료 시점에서 더 높은 우선순위의 스레드가 대기 상태에 있을 때

			-> 현대 대부분의 운영체제는 선점 스케줄링 사용
			-> 선점 스케줄링에 속하는 알고리즘으로는 RR(Round Robin), SJF(Shortest Job First), Priority(Preemptive version)

	===	3.	[ 기아와 에이징 ] ===
		  기아 : 스레드가 스케줄링 과정에서 선택되지 못한 채 오랜 동안 준비 리스트에 있는 상황
		
		[우선순위 기반 기아]
		-> 우선순위를 기반으로 하는 시스템에서는 더 높은 순위의 스레드가 계속 준비 리스트에 들어오면,
		 낮은 순위의 스레드는 스케줄링에서 계속 배제되어 오랜 동안 대기하게 되며 언제 실행될 지 알 수 없다.

		[실행 시간 짧은 우선 기반 기아]
		-> 실행 시간이 짧은 스레드를 우선 실행시키는 경우, 자신보다 짧은 스레드가 계속 준비 리스트에 들어오면
		    스레드는 선택에서 계속 배재되어 기아에 빠지게 된다.

	      에이징 : 기아에 대한 해결책으로 많이 활용되는 기법으로, 
		          -> 스레드가 준비 리스트에 머무르는 시간에 비레하여 우선순위를 높여주는 기법

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
		3)	[ 다양한 CPU 스케줄링 알고리즘 ]

		[=======[ 비선점 스케줄링 FCFS, SJF ]======]

		 [1] FCFS (First Come First Served) 스케줄링 - 처리율 낮음 (우선순위 없어 CPU burst 높은게 앞에 있으면 뒤에 다 기다리는 호위효과)

		  1. 알고리즘 : FCFS는 큐에 먼저 도착한 스레드를 먼저 스케줄링한다.

		  2. 스케줄링 파라미터 : 스레드 별 큐 도착시간

		  3. 스케줄링 타입 : 비선점 스케줄링 - 먼저 도착한 스레드가 실행을 마쳐야 다음 스레드가 실행되는

		  4. 스레드 우선순위 : 없음

		  5. 기아 - 발생하지 않음

		  Convoy Effect(호위효과) : 긴 CPU burst를 실행하는 스레드가 CPU를 양도할 때까지 뒤에서 대기하는 짧은 스레드들이
		                             오래 대기하여 시스템 전체가 느려지는 호위효과가 나타나는 단점이 있음.
		
		 [2] SJF (Shortest Job First) 스케줄링 - 우선순위가 실행시간(CPU burst Time)이 가장 짧은걸 우선.

		  1. 알고리즘 : SJF는 실행 시간이 가장 짧은 스레드를 먼저 실행시켜 스레드들의 평균 대기 시간을 최소화하는데 목적.
		                 SJF는 준비 큐에서 예상 실행 시간이 가장 짧은 스레드를 우선 선택한다.

		  2. 스케줄링 파라미터 : 스레드별 예상 실행 시간
		       -> SJF는 스레드 별 실행 시간 정보를 필요로 하는데 이 시간을 정확히 예측하는 것은 현실적으로 불가능.
		  
		  3. 스케줄링 타입 : 비선점 스케줄링
		       -> SJF는 선택된 스레드가 실행을 끝낼 때까지 중단시키지 않는 비선점 스케줄링이다.
		 
		  4. 스케줄링 우선순위 : 실행시간 짧은 스레드 but 선점이 아니므로 큐에서의 우선순위이다.

		  5. 기아 : 발생 가능 -> 짧은 실행 시간을 가진 스레드가 계속 큐에 도착하면 긴 스레드에 기아가 발생할 수 있다.

		  6. 성능 이슈 : 짧은 스레드를 먼저 실행하면 대기 중인 모든 스레드의 대기 시간이 짧아지므로 평균 대기 시간은 최소화 된다.
		                 -> 하지만 스레드의 실행 시간을 예측할 수 없기 때문에 현실에서 사용 안함. (이론만 존재)


	   [=======[ 선점 스케줄링 SRTF, RR, Priority ]======]
	    
	[1] SRTF (Shortest Remaining Time First) 스케줄링
		  
		  1. 알고리즘 : SRTF는 SJF의 선점 스케줄링 버전으로 남은 실행 시간이 가장 짧은 스레드를 우선 스케줄한다.
		                그러므로, 현재 실행 중인 스레드보다 더 짧은 실행 시간을 가진 스레드가 큐에 도착하면 현재 스레드 실행 중단

		  2. 스케줄링 파라미터 : 스레드 별 예상 실행 시간 - SRTF를 사용하기 위해서는 스레드 별로 예상 실행 시간과 남은 실행 시간 필요

		  3. 스레드 우선순위 : 실행 남은 시간 우선 - But 큐에서의 우선순위

		  4. 기아 현상 : 발생 가능 - 짧은 실행 시간을 가진 스레드가 지속적으로 큐에 도착하면, 긴 스레드는 언제 실행될 지 에측 못함.

		  5. 성능 이슈 : SJF와 마찬가지로 가장 짧은 쓰레드를 먼저 실행하므로 처리율은 높지만, 실행 시간 예측 못해 현실 사용 X

	[2] RR (Round Robin) 스케줄링

		  1. 알고리즘 : RR은 스레드들에게 공평한 실행 기회를 주기 위해 큐에 대기중인 스레드들을 타임 슬라이스 주기로 돌아가면서 선택한다.
		                 도착하는 스레드는 큐 끝에 삽입되며, RR은 준비 리스트의 맨 앞에 있는 스레드를 선택한다.
					   - 스레드는 실행이 시작된 후 타임 슬라이스가 지나면 커널에 의해 강제 중단되어 큐 끝에 다시 삽입됨.
					   - 커널은 한 번에 한 스레드에게 타임 슬라이스의 시간만큼 CPU를 사용하도록 한다.

		  2. 스케줄링 파라미터 : 타임 슬라이스

		  3. 스케줄링 타입 : 선점 스케줄링 
		               - RR은 스레드 실행 후 타임슬라이스가 지나면 강제로 중단시켜 큐 끝에 다시 삽입하고, 새 스레드를 선택하므로 선점 스케줄링.

		  4. 스케줄링 우선순위 - 없음

		  5. 기아 - 없음 
		               - 스레드는 타임 슬라이스만큼 돌아가면서 스케줄되고, 우선순위 없이 큐에 도착한 순서대로 스케줄되므로,
					      일정한 시간 후에는 반드시 실행 기회를 얻게 된다. 그러므로 기아가 발생하지 않는다.
		 
		  6. 성능 이슈
		    - [장점] : RR은 공평하고 기아가 없고 구현이 쉬운 장점이 있다. 
			- [단점] : 하지만 잦은 스케줄링으로 인해 스케줄링과 컨텍스트 스위칭에 소요되는 시간이 큰 단점.
			- 타임 슬라이스가 작을수록 자주 스케줄링하고 스위칭이 일어나 성능 저하가 심해짐.

			-> 타임슬라이스를 조절하면 FCFS와 SJF의 중도를 취하는 알고리즘이 된다.

	[3] Priority 스케줄링

		  1. 알고리즘 : Priority 스케줄링은 철저히 우선순위에 따라 스레드를 실행시키려는 목적의 알고리즘으로, 스레드마다
		                 고정 우선순위가 정해져 있는 상황에서, 큐에서 가장 높은 우선순위의 스레드를 선택한다.
					- 스레드가 도착할 때 우선순위에 따라 정렬하여 가장 높은 순위의 스레드가 큐의 맨 앞에 오도록 구현함.

		  2. 스케줄링 파라미터 : 스레드들의 우선순위 값

		  3. 스케줄링 타입 : 선점 / 비선점 모두 가능
		         [선점] : 더 높은 순위의 스레드가 도착할 때 현재 스레드를 중단하고 도착한 스레드를 실행시키면 선점
				 [비선점] : 현재 실행 중인 스레드가 종료한 후 스케줄링을 하게 되면 비선점 스케줄링이 됨.

		  4. 스레드 우선순위 : 스레드마다 고유 고정 우선순위

		  5. 기아 : 발생 가능 - 지속적으로 더 높은 순위의 스레드가 큐에 도착하는 경우.
		            -> 큐의 대기 시간에 비례하여 일시적으로 우선순위를 높이는 에이징 기법 결합 시 해결.
		  
		  6. 성능 이슈 : 우선순위가 높은 스레드일수록 대기 시간이나 응답 시간이 짧다. 운영체제들이 많이 씀.

	[4] MLQ (Multi-level Queue) 스케줄링
		  
		  1. 설계 의도 : 스레드들을 n개의 우선순위 레벨로 구분하고 레벨이 높은 스레드를 우선 처리할 목적으로 설계.

		  2. 알고리즘 : 
		        1) MLQ 알고리즘은 n개의 레벨(우선순위) 큐를 두고, 스레드를 레벨에 따라 큐에 삽입한다.
		        2) 스레드는 도착한 순서대로 큐에 삽입되며 다른 큐로 이동할 수 없다.
				3) MLQ 스케줄러는 가장 높은 레벨의 큐에서 맨 앞에 있는 스레들르 선택하며, 높은 레벨의 큐가
				    비어있을 때 그 아래 레벨의 큐에서 스레드를 선택한다.
				4) 큐마다 별도의 큐 스케줄러를 둘 수 있는데, 큐 앞에 배치하거나 MLQ 스케줄러가 큐에서 하나를
				    선택할 때 호출되도록 배치하여, CPU사용 시간 등 다른 지표를 이용하여 큐 내 스레드를 스케줄링 할 수도 있다.
					 [레벨 1 ,2, .. 큐] - [큐1, 2, ... 스케줄러] - [MLQ스케줄러]
		  
		  3. 스레드 우선순위 : 고정 우선순위 (n 레벨 중 하나)

		  4. 기아 : 발생 가능 - 지속적으로 높은 순위의 스레드가 큐에 도착하는 경우 낮은 우선순위의 스레드는 언제 실행될지 모름.

		  5. 성능 이슈 : MLQ는 높은 순위를 가진 스레드들의 대기 시간이나 응답 시간이 짧은 강점이 있다.
		                  하지만, 낮은 레벨의 큐에 있는 스레드가 높은 레벨의 큐로 이동할 수 없어 지속적으로 기아가 발생할 수 있음.
						   MLFQ가 이 기아 문제를 보완한 MLQ.

	[5] MLFQ (Multi-level Feedback Queue) 스케줄링

		  1. 설계 의도 : CPU burst가 짧은 스레드나 I/O 작업이 많은 스레드, 혹은 대화식 스레드를 우선 실행시켜
		                  스레드의 평균대기시간을 줄여 사용자의 응답시간을 짧게 하고 스레드에 기아가 발생하지 않게 함.

		  2. n개의 레벨 큐 : MLFQ는 우선순위(레벨)로 구분된 n개의 큐를 둔다.
		                    - 스레드는 우선순위가 없고 도착할 때 가장 높은 레벨의 큐에 삽입된다.
							- 높은 레벨의 큐를 먼저 스케줄링하며, 높은 레벨의 큐가 비어 있을 때만 아래 레벨 큐에서 스케줄링한다.
							- MLFQ는 큐마다 별도의 스케줄링 정책을 사용할 수 있지만 RR(먼저 온거 처리하면서, 공평한 타임슬라이스 기반)이 가장 무난하다. 
		  
		        -> 먼저 프로그램은 CPU burst와 I/O burst가 반복되는 실행 특성이 있다.
				-> MLFQ에서 각 큐는 CPU burst와 관계있다.
				-> 큐마다 타임슬라이스가 다르게 설정되는데, 우선순위 낮은 레벨의 큐일수록 타임 슬라이스가 크게 설정된다. 
				-> 실행 중인 스레드의 CPU burst가 큐의 타임 슬라이스를 넘어가면 강제 중단되어 아래 레벨 큐로 이동된다.
				-> 타임 슬라이스 전에 I/O 또는 양보되어 스레드의 CPU burst가 타임슬라이스 내에 끝나면 스레드는 동일한 큐에 다시 삽입된다.

				- MLFQ에서는 CPU burst가 작은, 즉 CPU 시간을 작게 소모하고 입출력이 빈번하 스레드가 높은 우선순위로 실행된다.
				- 높은 레벨의 스레드들이 모두 입출력 중이면, 그 아래 레벨의 큐에 있는 스레드가 실행됨.

		  3. 알고리즘
		        1) 도착하는 스레드는 가장 높은 레벨 큐에 삽입된다.
				2) MLFQ 스케줄러는 가장 높은 레벨 큐에서 스레드를 선택하여 실행시킨다. 만약 비어있으면 아래 레벨 큐에서 선택.
				3) 실행 중인 스레드의 CPU burst가 큐 타임 슬라이스보다 길어지면, 강제로 중단시켜 아래 레벨의 큐로 이동시킨다.
				4) 스레드가 실행 중 자발적으로 중단하면 동일 큐에 다시 삽입됨.
				5) 스레드가 I/O를 요청하면 해당 큐에서 나오지만, I/O작업이 끝나면 동일한 큐로 다시 삽입된다.
				6) 큐에서 대기하는 시간이 오래되면 기아를 막기 위해 한 레벨 위의 큐로 이동시킨다.
				7) 최하위 레벨의 큐는 주로 FCFS나 긴 타임 슬라이스의 RR로 스케줄된다.

		 4. 스케줄링 파라미터 : 큐의 개수, 각 큐의 스케줄링 라고리즘, 각 큐의 타임슬라이스 기준, 기아 막기위한 레벨 올리기 위한 시간 기준 등.

		 5. 스케줄링 타입 : 선점 스케줄링
		                -> MLFQ는 실행중인 스레드의 CPU burst가 큐의 타임 슬라이스를 초과하면 스레드를 강제 중단시킴.
						 BUT! 더 높은 레벨의 큐에 새로 스레드가 도착한다고 하더라도 실행중인 스레드를 강제 중단시키진 않는 원칙(비선점 특징 있음)

		 6. 기아 : 없음 -> 이론적으로는 스레드가 낮은 레벨의 큐에 오랜시간 머물면 에이징 기법을 써서 기아 발생안함.
		                    하지만, 큐 개수가 많거나 높은 레벨의 큐에 스레드들이 많은 경우 기아 발생 가능성 있음.

		 7. 성능 이슈 : MLFQ에서는 CPU burst가 짧거나 입출력이 빈번한 스레드, 혹은 대화식 스레드에게 높은 우선순위를 주어 응답 시간을
						 빨리하고 평균 대기 시간을 줄인다. 또한 기아를 막을 수 있고, 큐의 개수나 타임 슬라이스 값 등 스케줄링 
						 파라미터를 조절하여 대상 시스템에 적합하게 구현할 수 있는 유연성이 뛰어나지만, 알고리즘이 복잡하여 CPU 오버헤드가 증가하는 단점 존재.

		  
		  pg~278



																																																																																						*/