//============2025-07-01==========
#include <iostream>
#include <thread>
#include <chrono>
#include <vector>
//using namespace std;

//========================  [ 스레드 개념 ] ======================================//
																																					/*
	[부족한 개념]
	** 인터럽트 서비스 루틴 **
    - 위치) 디바이스 드라이버나 커널 코드에 있다.
	디바이스 드라이버 : 장치를 제어하여 장치로부터 입출력을 수행하는 프로그램. 해당 장치로부터 발생하는
						인터럽트를 처리하는 서비스 루틴이 들어있음.
		-> 디바이스 드라이버는 운영체제의 한 부분으로서 장치마다 하나씩 필요하며 장치와 커널 사이에 제어명령
		    과 데이터를 전달하는 인터페이스 역할을 한다. 커널 코드가 장치와 무관하게 작성되고 운영될 수 있도록 해줌,

  
  1) 스레드가 왜 탄생했냐(운영체제 전공책)
	- 프로세스의 문제점 때문

	1. 프로세스는 생성 비용이 너무 높다
	 - 비용이 크다 
	 -> 모든 프로세스는 독립적인 메모리 공간을 가짐
	 -> 자식 프로세스 생성 시(fork로 자식 프로세스 생성 시) 프로세스만의 코드, 데이터, 스택 등 전체 메모리 구조를 복사
	 
	2. 프로세스 간 통신이 복잡하다
	 -> 서로 메모리를 공유하지 않기 때문에 통신을 위한 특별한 기법 필요
	 -> 프로세스들은 공유메모리, 신호, 파이프, 소켓, 파일, 메세지 큐, 세마포, 메모리맵파일 등 
	     다양한 기법으로 커널 메모리나 커널에 의해 마련된 메모리 공간을 이용하여 데이터 주고받음
	 -> 이 기능들은 커널의 직접적인 지원을 받기 때문에 응용프로그램들은 운영체제 사이에 호환성도 부족,
	     개념이 복잡하고, 성능도 낮다.

	3. 프로세스 컨택스트 스위칭의 큰 오버헤드
	 -> 현재 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행시키는 컨택스트 스위칭에
	     시간적 공간적 오버헤드가 큼.
	 -> 구체적으로 이 시간은 현재 실행 중인 프로세스의 매핑 테이블을 새로 실행될 프로세스의 매핑 테이블로 교체하는 시간,
	     현재 실행중인 프로세스의 CPU컨택스트를 PCB에 저장하고 새로 실행될 프로세스의 컨택스트를 CPU로 옮기는 시간,
	      캐시 메모리에 들어 있는 현재 프로세스의 코드나 데이터를 무력화시키고 실행될 프로세스의 코드나 데이터를 적재하는 시간.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

   2) 스레드 개념

	 1. 스레드 출현 목적
	  프로세스보다 작고 쉽게 데이터를 주고받을 수 있는 실행 단위를 위해 탄생
	   이로인해 프로세스보다 작은 크기의 실행 단위라고 해서 가벼운 프로세스 (Light-weight process LWP)라고 부른다
	  
	  - 프로세스보다 작은 실행 단위 필요
	  - 프로세스의 생성 및 소멸에 따른 오버헤드 감소
	  - 빠른 컨택스트 스위칭
	  - 프로세스들 사이의 통신에 대한 어려움 해소

     2. 스레드 개념
	  스레드를 실행 단위로 다루는 운영체제를 멀티스레드 운영체제(Multi-Threaded Operating System)라고 함.
	   현대의 거의 모든 운영체제가 멀티스레드 운영체제


	 - 스레드는 실행 단위이며 스케줄링 단위이다.

	  -> 스레드는 응용프로그램 개발자에게는 작업을 만드는 단위이며, 운영체제에게는 실행 단위이고 CPU를 할당하는 스케줄링 단위이다.
	  -> 스레드는 코드, 데이터, 힙, 스택이 담긴 주소공간을 가진 실체 (운영체제에 의해 관리되는 실행 단위)
	  -> 실행 단위라는 뜻은 스레드마다 TCB(Thread Control Block) 구조체를 두고 스레드 ID, 스케줄링 우선순위 등
	  스레드 정보를 관리하며, 생성, 소멸, 스케줄링 등 스레드를 독립된 단위로 다룬다는 의미.
	  -> 운영체제는 TCB를 통해 스레드의 존재를 인식하며 TCB 중 하나를 선택하여 CPU에게 실행시킴.


	 - 프로세스는 스레드들의 컨테이너이다. [실행 주체가 스레드]

	  -> 프로세스는 여러 스레드를 담는 컨테이너.
	  -> 스레드는 독립적으로 존재할 수 없고 프로세스 안에 존재.
	  -> 여전히 운영체제는 응용프로그램을 실행시키기 위해 프로세스를 생성하고 관리.
	  -> 프로세스가 실행단위가 아니고 스레드가 실행 단위이므로, 스레드를 가지지 않는 프로세스는 있을 수 없음
	  -> [메인 스레드!] : 프로세스 생성 시, 커널은 자동으로 프로세스 내에 1개의 스레드를 생성하는데, 이를 메인 스레드라고 함.
	  -> 프로세스가 실행을 시작한다는 것은 곧 메인 스레드가 실행을 시작하는 것
	  -> 메인 스레드가 다른 스레드를 생성하고, 스레드가 또 다른 스레드를 생성함으로서 프로세스가 여러 개의 스레드를 가진다.


     - 프로세스는 스레드들의 공유 공간 제공!! [스레드 간 소통을 위해]

	  -> 프로세스는 스레드들이 공유할 수 있는 공간을 제공.
	  -> 스레드들은 프로세스의 주소 공간을 나누어 사용한다.
	  -> 프로세스의 주소 공간 내에 스레드의 코드들이 적재되며, 스레드들은 프로세스 내에 작성된 함수(코드)들을 어떤 것이든
	      호출할 수 있고 프로세스 내에 선언된 전역 변수를 액세스할 수 있으며, 프로세스의 힙을 공유
	   [스레드들은 프로세스의 주소 공간을 공유하므로 데이터, 코드 힙을 공유]
	    [이유 및 효과]-> 이 공유 환경은 프로세스에 속한 스레드들끼리 상호 데이터를 주고받는데 매우 편리한 환경 제공
	    [BUT!] 한 프로세스에 속한 스레드들은 통신 쉬움, 다른 프로세스에 속한 스레드 사이의 통신은 프로세스 사이의 통신과 다를 바가 없음


	 - 스레드가 실행할 작업은 함수로 작성한다
	  
      -> 스레드가 실행할 작업은 함수로 작성하고, 스레드가 사용할 데이터는 함수 내 지역변수나 전역 변수로 만든다.
	  -> 함수를 만든다고 자동으로 스레드가 되는 것은 아님. 운영체제에게 이 함수를 스레드로 만들어
	      줄 것을 요청해야 함. 그러면 운영체제가 TCB를 하나 만들고, 함수의 시작 주소를 TCB에 기록.
	       그리고 이 TCB가 스케줄링 되면 기록된 주소에서 실행이 시작된다.

	
	- 스레드와 프로세스의 생명
	 
	 -> 스레드로 만든 함수가 종료하면 스레드가 종료된다.
	 -> 스레드가 종료되면 운영체제가 TCB 등 스레드 관련 정보를 모두 제거한다.
	 -> 프로세스에 속한 모든 스레드가 종료할 때 프로세스도 종료되며 프로세스에 할당된 모든 메모리와 자원이 시스템에서 제거.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    3) 스레드 주소 공간


	 - 스레드의 주소 공간은 스레드가 실행 중에 사용하는 메모리 공간으로 스레드의
	    코드 데이터 힙 스택 영역이며, 이들은 모두 프로세스의 주소 공간에 형성된다.

	 - 스레드의 주소 공간은 프로세스 주소 공간 내에서 스레드가 사적으로 사용하는 공간과
	    스레드 사이의 공유 공간으로 나뉜다.

	 [스레드 간 메모리]

		{공유 공간}
		 1. 코드 영역 - 프로세스 코드 영역에 할당
		 2. 데이터 영역 - 프로세스 데이터 영역에 할당
		 3. 힙 영역 - 프로세스 힙 영역에 할당

		{사적 영역}
		 1. 스택 영역 - 프로세스 사용자 영역 스택에 할당
		 2. TLS(Thread Local Storage) - Process Data 영역에 할당

		[안전 영역]
		 1. 코드 영역 - 공유해도 무관
		 2. 스택 영역 - 스레드 간 개별 영역

		[임계 영역]
		 1. 데이터 영역 - 전역 공간으로 공유자원에 해당
		 2. 힙 영역 - 동일 메모리 공간 가르키므로 공유자원에 해당

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	[멀티 스레딩과 동시성(Concurrency)와 병렬성(Parallelism)]

	1. Concurrency - 동시성
	 - 1개의 CPU로 2개 이상의 스레드(혹은 프로세스)를 시간을 나누어 실행하는 것.
	 - 스레드가 입출력을 기다리는 동안 CPU가 다른 스레드를 실행하거나 스레드에 할당된
	    타임 슬라이스가 다할 때, CPU를 다른 스레드에게 할당하여 실행하는 식으로 여러 스레드 동시 실행.

	2. Parallelism - 병렬성
	 - 2개 이상의 스레드가 서로 다른 CPU에서 동시에 실행되는 것을 뜻한다. 
	 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
																																																																																	*/
//======================== [ 전공서 예제 ] ======================================//

using namespace std;
thread_local int tsum = 5; //스레드 별로 존재

int total = 0;//->atomic<int>total = 0; 으로 바꿔야 동기화

void printSum() {
	cout << tsum << '\n';
}

void calcThread(int param) {

	cout << "스레드 생성 초기 tsum = " << tsum << '\n';

	int sum{};
	for (int i = 1; i <= param; ++i)sum += i;

	tsum = sum;
	printSum();
	total += sum;

}

int main() {
	cin.tie(nullptr);
	ios_base::sync_with_stdio(false);

	vector<thread>threads;
	threads.push_back(thread(calcThread, 100));
	cout << "첫 스레드 생성\n";
	threads.push_back(thread(calcThread, 200));
	cout << "두번째 스레드 생성\n";

	for (auto& th : threads) {
		th.join();
		cout << "calcThread 스레드가 종료되었습니다." << '\n';
	}

	cout << "total = " << total;

}

		//[결과]
																																																																		/*
		첫 스레드 생성
		두번째 스레드 생성
		스레드 생성 초기 tsum = 5스레드 생성 초기 tsum = 5  -> cout에서 <<기준으로 실행하여 스레드 개입하여 '\n'까진 출력못하고 컨택스트 스위칭
		
		20100
		5050
		calcThread 스레드가 종료되었습니다.
		calcThread 스레드가 종료되었습니다.
		total = 25150  -> 동기화 되지 않아 문제 -> UB , 우연히 값이 맞은 상황

																																																																										/*
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	4) 스레드 상태와 스레드 운용(operation)
	 
	 - 준비 상태 (Ready) - 스레드가 스케줄을 기다리는 상태
	 - 실행 상태 (Running) - 스레드가 현재 CPU에 의해 실행되고 있는 상태
	 - 블록 상태 (Blocked) - 스레드가 입출력을 요청하거나, sleep()과 같은 시스템 호출로 커널에 의해 중단된 상태
	 - 종료 상태 (Terminated) - 스레드가 종료된 상태

	-> 스레드 상태는 TCB에 저장된다. 

	 1. 스레드 생성
	  - 프로세스를 생성할 때 운영체제는 자동으로 main 스레드를 생성. 
	  - main 스레드를 제외하고, 스레드는 스레드에 의해 생성되는데 이들을 부모-자식 스레드로 부른다.
	  - 프로세스만큼 부모 자식 관계가 의미있진않음. 특히 부모 스레드가 종료한다고 자식 스레드가 종료되지 않고, 통보도 안함
	  - 다만 부모 스레드는 자식 스레드를 생성하였기 때문에 자식 스레드에 대한 스레드 ID를 가지고 있어 자식 스레드를 제어 가능 (detach로 없앨순있지만)

	  [생성 과정]
	  - TCB 구조체를 만든 후 스레드 ID 부여
	  - 스레드가 실행을 시작할 코드(함수)의 주소를 TCB의 PC에 기록
	  - 스레드 스택 공간을 할당하고 그 주소를 TCB의 SP에 저장한 후 스레드 상태를 Ready로 하고 스레드 준비 리스트에 넣음
	  - TCB를 프로세스의 PCB와 다른 TCB에 연결하면 끝.

	 2. 스레드 종료
	  - 프로세스의 종료는 main 스레드가 종료하는 경우나 어떤 스레드가 exit() 시스템 호출을 부르는 경우,
	     혹은 모든 스레드가 종료되는 경우
	  - 스레드가 다른 스레드를 강제 종료하는 방법은 일반적으로 제공되지 않음.
	  - 한 스레드가 다른 스레드를 종료시키려면 약속된 신호를 보내고, 수신하는 스레드가 약속된 신호를 받으면 스스로 종료되도록 코딩해야함.
	  - 스레드 종료는 TCB가 시스템에서 제거되고 TCB가 연결된 링크들이 해제되는 것으로 매우 단순하다.
	  - 스레드 종료 후에도 스레드 코드 등 스레드에게 할당된 영역은 프로세스 영역 내에 그대로 남아있다.
	  - 스레드가 실행했던 함수의 코드는 그대로 존재, 스레드가 동적 할당 후 해제하지 않은 메모리는 할당된 상태로 남아 있다.
	  - 다른 스레드가 이 주소를 기억하고 있었으면 모르겠지만, 그렇지 않으면 이미 할당되었던 주소이므로 
	     프로세스가 종료될 때까지 다른 스레드에게 할당할 수 없는 상태가 된다 (메모리 누수) 
	 
	 3. 스레드 조인
	  - 스레드 조인은 스레드가 다른 스레드의 종료를 기다리는 행위이다.
	  - 스레드 번호(tid)를 알면 아무 스레드나 다른 스레드를 조인할 수 있지만, 스레드 조인은 보통 부모 스레드가 자식 스레드의 tid를 알기 때문에
	     부모가 자식을 기다릴 때 보통 사용됨.

	 4. 스레드 양보
	  - 스레드 양보는 실행 중인 스레드가 다른 스레드에게 CPU를 양보하기 위해 스스로 실행을 중단하는 행위이다.
	  - 양보한 스레드는 Ready 상태로 준비 큐에 들어가고, 준비 큐에 있는 스렏 중 하나가 스케줄링되어 실행된다.
	  - 준비 큐에 아무 스레드가 없으면 양보한 스레드가 다시 실행됨.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------


	5) 스레드 컨택스트와 스레드 제어 블록(TCB)

	 1. 스레드 컨택스트 (Thread Context) - CPU가 스레드를 실행되고 있을 때 CPU의 레지스터 값들

	  - 스레드 컨택스트란 스레드가 현재 실행중인 일체의 상황을 말함.
	  - 그 일체의 상황은 CPU 내의 레지스터들과 메모리에 담김.
	  - 메모리에는 코드와 데이터가 있고 스택에는 현재 실행 중인 함수의 매개변수와 지역변수 등이 저장되어 있음.
	  - CPU의 PC 레지스터는 현재 실행 중인 스레드의 코드 주소, SP 레지스터는 스레드 스택의 TOP 주소
	  - 여러 데이터 레지스터에는 실행 결과나 실행에 사용될 데이터들이, 상태 레지스터에는 CPU의 상태정보와 프로그램에 의해 설정된 제어 정보들이 들어있음.

	  -> 스레드 코드, 데이터, 스택 등 메모리에 저장된 정보는 프로세스의 공간에 그대로 있기 때문에
	      CPU 레지스터들만 저장하면 현재 실행 중인 스레드의 컨택스트를 저장할 수 있다.


	 2. 스레드 제어 블록 (Thread Control Block) - Thread Context 내용도 담음
	  
	  - 커널은 스레드를 실행 단위로 관리하기 위해, 커널 내에 스레드마다 스레드 제어 블록(TCB)라는 구조체를 만들어 관리한다.
	  - TCB는 스레드가 생성될 때 만들어지고 종료되면 제거된다.
	  - CPU가 명령을 실행할 때마다 TCB의 컨택스트 정보들(PC, SP, Other registers)을 수정하는 것은 아님.
	  - TCB의 컨텍스트 정보들은 스레드가 실행이 중단되어 컨텍스트 스위칭될 때 그 때 CPU 레지스터들의 값들이 저장됨.
	  - CPU마다 레지스터 개수와 크기가 다르므로 TCB에 저장되는 컨텍스트 크기도 CPU에 따라 다르다.

	  [TCB 구성 요소]
	  -> tid : 스레드 ID 고유번호
	  -> state : 스레드의 상태 정보
	  
	  -> PC : CPU의 PC 레지스터 값 - 다음 실행 명령 주소
	  -> SP : CPU의 SP 레지스터 값 - 스레드 스택의 Top 주소
	  -> 다른 레지스터들

	  -> 우선순위 : 스케줄링 우선순위 정보
	  -> CPU 사용시간
	  
	  -> PCB주소 : 스레드가 속한 프로세스 제어 블록 주소
	  -> 다른 TCB 주소 : 프로세스 내에 다른 TCB연결 목적
	  -> 블록 리스트, 준비리스트 : 입출력을 대기하고 있는 스레드들을 연결하는 TCB 링크

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	  //pg 219부터 다시

	6) 스레드 컨텍스트 스위칭
	 
	 정의) 현재 CPU가 실행 중인 스레드를 중단시키고 CPU에게 새 스레드를 실행시키는 과정
	 
	 1. 스케줄링 : 커널은 스케줄러 코드를 이용하여 새로 실행시킬 스레드를 선택
	  2. 컨텍스트 스위칭 : 현재의 스레드의 CPU 레지스터들의 값을 TCB에 저장하고 선택된 스레드의
	      TCB로부터 스레드 컨텍스트를 CPU에 적재하여 새 스레드를 실행시킴

	  [컨택스트 스위칭 발생 경우] - 시스템 호출 or 인터럽트 서비스 실행 시.

	  1. 스레드가 자발적으로 다른 스레드에게 양보하는 경우 (시스템 호출 내) 
	 
	 -> 이 경우는 2가지로 나뉨 
	      - 스레드가 직접 yield() 시스템 호출을 불러 양보하는 경우 (running -> ready 상태 리스트로 이동) 
		  - sleep() 이나 wait()등의 시스템 호출 (running -> blocked -(interupt)-> ready 상태 리스트로 이동)
	  
	  2. 스레드가 I/O 작업을 요청하는 시스템 호출 시 블록되는 경우 (시스템 호출 내) - [Blocked -> Ready]
	  
	  -> 스레드가 파일을 읽기 위해 read() 시스템 호출을 부르면, 디스크 장치로부터 파일이 읽혀질
	      때까지 실행이 진행될 수 없기 때문에, 커널은 강제로 현재 스레드를 블록 상태로 바꾸고 준비 리스트
	       에서 다른 스레드를 선택한 후 컨텍스트 스위칭한다.
	  
	  -> I/O 작업은 CPU가 아닌 장치 컨트롤러가 수정 , I/O 요청 전달은 blocked로 스레드 상태를 전환시키고 완료되면
	      CPU에 인터럽트로 알려 OS가 스레드를 Ready 큐로 이동, 이후 스케줄러에 의해 running이 결정

	  3. 스레드가 타임 슬라이스를 소진한 경우 (인터럽트 서비스 루틴 내) - [Running ->Ready]
	  
	  -> 대부분의 운영체제 타임 슬라이스 단위로 돌아가면서 스레드를 실행시킨다. 이때 커널은 타이머 인터럽트를 
	      이용하여 스레드의 실행 시간을 체크하고 스레드가 CPU 타임슬라이스를 소진한 경우 강제로 중단시켜 준비 리스트에 넣는다.

	  4. I/O 장치로부터 인터럽트가 걸린 경우 (인터럽트 서비스 루틴 내)
	  
	  -> 현재 실행중인 스레드보다 더 높은 순위의 스레드가 블록 상태로 I/O 완료를 기다리고 있는 상황에서,
	      I/O 작업이 완료되어 I/O 장치로부터 인터럽트가 발생하면, 인터럽트 서비스 루틴은 현재 스레드를 강제로
	       중단시켜 준비 리스트로 옮기고, I/O 작업 완료를 대기 중인 높은 순위의 스레드로 컨텍스트 스위칭한다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	7) 스레드 스위칭이 이루어지는 위치 및 과정
	  
	  위치) 스레드 스위칭은 시스템 호출을 처리하거나 인터럽트 서비스 루틴의 실행 도중 커널 코드에서 이루어진다.

	  과정)
	  1. CPU 레지스터 저장 및 복귀
	  -> 먼저 현재 실행중인 스레드 A의 컨텍스트를 TCB-A에 저장한다.
	   - 현재 스레드의 코드와 스택의 주소, 그리고 CPU 내에서 처리 중인 데이터들을 모두 저장해두기 위해, 
	      CPU의 PC, SP, 데이터 레지스터 등을 TCB-A에 저장하는 것.
	 
	  -> 그리고 나서, TCB-B에 저장된 스레드 B의 컨텍스트를 CPU에 적재시킨다. 이로 인해 CPU는 스레드 B가 
	      이전에 중단된 위치에서 실행을 재개할 수 있으며 자신의 스택도 되찾게 된다.

	  2. 커널 정보 수정
	  -> TCB-A와 TCB-B에 스레드 상태 정보와 CPU 사용 시간 등을 수정하고, TCB-A를 준비 리스트나 블록 리스트로 옮기고,
	      TCB-B를 준비 리스트에서 분리하는 등 TCB 리스트를 조작하는 작업을 한다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------


	8) 컨텍스트 스위칭의 오버헤드!! -> 레지스터 저장, 스케줄러 실행, TLB Flush, Cache miss, Page Fault
	
	[Ready큐는 커널이 소유하지만(자료구조 관리), 스케줄링 및 읽어가는건 CPU가 함.]
	
	- 멀티스레드 운영체제에서 스레드의 컨텍스트 스위칭은 필연적이다. 하지마느 컨텍스트 스위칭은
	   CPU를 전적으로 사용하는 작업으로 상당량의 CPU 시간을 소모한다. 컨텍스트 스위칭에 걸리는 시간이
	    크면 컴퓨터의 처리율이 상대적으로 떨어지므로 스레드 스위칭 시간을 최소화할 필요가 있다.

	 1. 동일한 프로세스의 다른 스레드로 스위칭하는 경우

	  1.1) 컨텍스트 저장 및 복귀 시간
	   - 현재 CPU 상태를 스레드의 TCB에 저장하고, 새로 선택된 스레드의 TCB에 저장된 레지스터 값들을 CPU에 복귀하는 시간.
	  
	  1.2) TCB 리스트 이동 시간 
	   - 스레드의 TCB를 준비 리스트나 블록 리스트 등으로 옮기는 시간

	  1.3) 캐시 플러시 및 채우기 시간 (Cache Line -> 64byte)
	   - 현재 CPU 캐시에 담겨 있는 스레드 코드와 데이터를 지우거나 변경된 데이터를 메모리로 플러시하는(복사)
	       시간이 소요된다. 
	   
	   - 새로 실행될 스레드의 코드와 데이터가 CPU 캐시에 채워지는 것은 컨텍스트 스위칭 이후 새 스레드가
	      실행하는 동안 이루어지므로 컨텍스트 스위칭 시간에 포함되진 않는다.
	 
	 2. 다른 프로세스의 스레드로 스위칭되는 경우
	  
	  2.1) 메모리 관련 오버헤드
	   - 프로세스의 노닐 주소를 물리 주소로 매핑하는 MMU(Memory Management Unit) 장치 내에 들어 있는
	      이전 맵(페이지) 테이블을 제거하고 새로운 프로세스의 맵 테이블을 적재해야 한다. 
	   
	   - 이 과정에서 새로운 프로세스의 코드나 데이터가 메모리에 없고 하드 디스크에 있어 이를 메모리로
	      옮겨와야 하는 과정(페이지 폴트)이 발생하기도 한다.
	   
	   - CPU 내에 현재 프로세스의 TLB(Translation Look-aside Buffer)를 모두 비우고, CPU에 새 프로세스의
	      TLB를 채우는 작업이 필요한데 비용이 크다.

	  2.2) 추가적인 캐시 오버헤드 (cache invalidate 무효화) 관련
	   - 프로세스가 바뀌기 때문에 현재 CPU 캐시에 담긴 프로세스의 코드와 데이터도 무효화시켜야한다.
	   
	   - 이후, 새 프로세스의 스레드가 실행을 시작하면 CPU 캐시에 계속 캐시 미스가 발생하고 캐시가 채워지는
	      과정이 진행되는데 여기에도 상당한 시간이 소요됨.
	
	3. 스레드 스위칭 오버헤드 줄이기
	 - 멀티스레드 운영체제에서 스레드 스위칭이 매우 자주 발생한다. 컨텍스트 스위칭은 상당한 CPU시간이
	    소모되는 CPU 집중작업으로, 컨텍스트 스위칭 시간이 클수록, 횟수가 많을수록 처리율이 떨어지므로 이를
	     최소화해야함.
	
	 - 멀티 코어 CPU를 가진 현대의 컴퓨터 시스템에서는 프로세스를 특정 CPU 코어에 배치하여,
	    CPU 코어가 여러 프로세스에 걸쳐 스레드를 실행하지 않도록 하는 방법을 사용하기도 하고, 
	 
	 - (하이퍼스레딩) CPU와 TCB 사이에 컨텍스트를 이동하는 작업을 없애기 위해 CPU에 스레드 별로 레지스터 셋을 따로 두어,
	      컨텍스트 스위칭 시 현재 실행 중인 스레드의 CPU 레지스터들을 TCB에 저장하지 않는 방법을 사용하기도 함.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	9) 커널 레벨 스레드와 사용자 레벨 스레드 (CPU는 커널이 정해준 스케줄링에 따라 실행만 함, 판단X)

	  - 스레드 스케줄링 주체가 커널이냐 스레드 라이브러리이냐에 따라 커널 레벨, 사용자 레벨 스레드로 나뉨.
	  - 스레드 정보를 담은 TCB를 생성하고 소유하고 있는 주체가 커널인지 스레드 라이브러리인지에 따라 구분.

	 1. 커널 레벨 스레드 - 커널 공간에 만들어질뿐 실행하는 코드는 사용자 공간일 수 있음.
	
	  정의) 커널 레벨 스레드란, TCB가 커널에 의해 커널 공간에 만들어지고 커널에 의해 스케줄되는 스레드이다.
	
	  - 스레드 조인, 동기화 등 스레드 운용의 모든 기능은 커널에 의해서만 제공되므로, 커널 스레드들은
	     시스템 호출을 통해서만 이 기능을 활용할 수 있다. -> TCB가 커널에 있기 때문.

	  - 커널 레벨 스레드의 코드와 데이터가 사용자 공간 또는 커널 공간에 있을 수 있다. 커널 공간에서 
		 실행되도록 작성된 커널 레벨 스레드는 순수 커널 레벨 스레드라고 말한다. 대부분 운영체제 스레드들이다.

	 2. 사용자 레벨 스레드

	  정의) 스레드 라이브러리에 의해, 사용자 공간에 생성되고, 관리되고, 스케줄되는 스레드를 사용자 레벨
			 스레드를 사용자 레벨 스레드라고 한다. 

		- 스레드의 TCB가 스레드 라이브러릴에 의해 사용자 공간에 생성되고 관리되므로, 사용자 레벨 스레드에 대한
	       존재는 커널에 전혀 알려지지 않는다.

		- 스레드 라이브러리는 응용프로그램에 링크되어 응용프로그램의 바이너리 코드에 합쳐지기 때문에, 응용프로그램이
		   적재될 때 함께 사용자 영역에 적재된다.
		 
		- 응용 프로그램은 스레드 라이브러리의 함수를 호출하여 스레드를 생성하고, 스레드 라이브러리는 생성한 TCB를 
		   사용자 공간에 저장한다. 스레드의 탄생, 조인, 스케줄링, 동기화, 종료 등 모든 관리가 사용자 공간에서 이루어짐.


		[사용자 레벨 스레드 vs 커널 레벨 스레드] - std::thread는 커널 레벨 스레드

		구현 : 스레드 라이브러리에 의해 구현되고 다루어짐 vs 커널에 의해 구현, 커널 API (시스템 호출)

		스레드 스위칭 : 사용자 모드에서 스레드 라이브러리에 의해 실행 vs 커널 모드에서 커널에 의해 실행

		컨텍스트 스위칭 속도 : 100배 빠름 vs 커널 내에서 상당 시간 지연

		멀티스레드 응용프로그램 : 스레드 라이브러리를 이용하여 작성 쉬움, 생성 빠름 vs 시스템 호출을 이용하여 생성, 생성 느림

		이식성 : 운영체제 상관없이 작성 가능, 스레드 지원 안하는 운영체제에서도 가능 vs 스레드를 생성하고 다루는 시스템 호출이 운체마다 다름

		병렬성 : 멀티 코어 CPU에서 멀티스레드의 병렬처리 안됨 vs 높은 병렬성, 서로 다른 CPU나 서로 다른 코어에서 병렬 실행 가능

		병렬성 종류 : 동시성 vs 병렬성

		블록킹 : 시스템 호출 도중 입출력 등으로 중단되면 프로세스의 모든 사용자 레벨 스레드가 중단 vs 중단되어도 해당 스레드만 중단

		커널 부담 : 없음 vs 커널 코드의 실행 시간 증가, 시스템 전체에 부담

		스레드 동기화 : 스레드 라이브러리에 의해 수행 vs 시스템 호출을 통해 커널에 의해 수행

		최근 경향 : 멀티 코어 CPU에 적합하지 않아 줄어드는 추세 vs 멀티 코어에 높은 병렬성을 얻어 많이 사용됨. 

		pg232
																																																																								*/

//======================== [ std::thread 기본 사용법 ] ======================================//
// [필요 표준 헤더 파일] #include <thread>  - C++11~
		
void do_work() {
	std::cout << "Thread Create Method\n";
																																																						/*
	 1. void do_work() 
																			
	  타입 : void (*)() 함수 포인터 callable
																																																*/
}

int main() {
	std::thread t(do_work); 
	t.join();
																																																									/*
	  2. std::thread t(do_work) 

		생성자 : do work 함수를 실행하는 새로운 OS-Level 스레드 생성
				-> do_work 주소(함수 포인터로)가 std::thread 생성자로 전달 - 데이터 영역의 코드 주소가 전달
																																																			*/

}
		
//======================== [ std::thread 핵심 메서드 ] ======================================//

	std::thread t1(do_work);
	
	t1.join();
																																													/*
	1. [ join() ]

	- 해당 스레드가 종료될 때까지 메인 스레드가 기다림

	- 반드시 호출해야 함 (안 하면 프로그램 종료 시 std::terminate() 발생)
		
	- 메인 스레드가 먼저 종료 시, terminate()	
																																				*/

	std::thread t1(do_work);

	t1.detach();
																																						/*
	2. [ detach() ] - 하고나면 추적 불가하므로 잊고 살기

	- 스레드를 독립적으로 실행시키고 소유권을 해제

	- 스레드 종료 여부를 알 수 없음

	- 주의: detach() 후 해당 스레드가 죽은 객체에 접근하면 undefined behavior

====== [detach에 대한 고찰] ======
																																			*/
	void fn() {
		std::cout << "fn" << std::endl;
	}

	void threadCaller() {
		std::thread t1(fn);
		t1.detach();
	}

	int main1() {
		threadCaller();
																																																	/*
		main 스레드에서 threadCaller() 함수 호출을 통해 main함수 스택 프레임에 t1 thread가 적재
		이후, detach를 통해 fn()를 실행하는 주체인 t1 스레드는 추적 불가 상태가 됨.
		threadCaller() 함수가 종료 후 스택프레임 반환과 동시 원래 t1도 join되어 스레드 종료가 정상적이지만
		해당 경우 독립적으로 실행되는 스레드이므로 함수 종료 이후에도 실행.
		하지만, 더이상 추적할 방법이 없어 권장 X
																																													*/


		std::this_thread::sleep_for(std::chrono::seconds(3));
																																																				/*
		메인 스레드 종료되기 전(프로세스 종료 전)에 t1이 fn을 실행할 시간을 벌어주기. 
		t1은 detach로 소유권 잃고 OS수준의 스레드가 되어 백그라운드에서 독립적으로 실행
		만약 t1이 fn 실행 전 메인 스레드 종료 시 t1은 terminate되진 않고 그냥 조용히 아무 출력없이 종료
																																																	*/
	}
																																								/*
	======[detach에 대한 고찰 대체 방안] ======
																																									*/
	std::thread gThread;
	
	void fn() {
		std::cout << "fn" << std::endl;
	}

	void threadCaller() {
		gThread = std::thread(fn);
	}

	int main2() {
		
		threadCaller();

																																											/*
		- gThread는 전역으로 유지되며 소유권을 유지함
		- join을 통해 스레드의 정상 종료를 명확히 기다림
		- main함수 종료 전까지 스레드 종료됨을 보장
																																								*/

		std::this_thread::sleep_for(std::chrono::seconds(3));

		gThread.join();
	}

//--------------------------------------------------------------

	std::thread t1(do_work);

	t1.joinable();
																																										/*
	3. [ joinable() ] 

	- 해당 스레드가 join이나 detach 되지 않은 상태인지 확인

	- 안전하게 join()할 수 있는지 검사할 때 필수
																																		*/


	std::thread t1(do_work);

	t1.get_id();
																																	/*
	4. [ get_id() ]

	- 해당 스레드의 고유 ID 반환 (비교/해시 가능)

	- std::this_thread::get_id()로 현재 실행 중인 스레드의 ID도 확인 가능

	
																																	*/
	std::thread t1(do_work), t2(do_work);

	t1.swap(t2);
	t1 = t2;
																																								/*
	5. [ swap() / operator= ]

	- 두 스레드 객체의 내부 핸들을 교환

	- 복사는 불가하지만 이동(move) 은 가능


																																*/

//======================== [ std::thread 생성 인자 ] ======================================//

																																															/*
	[ 일반 함수 + 값 인자 ]
																																															*/	
	void print(int a, char c) {
		std::cout << a << " " << c << "\n";
	}

	std::thread t(print, 10, 'X'); // OK

																																																/*
	[ 람다 함수 ]
																																																	*/
	std::thread t([](int x) {
		std::cout << "x = " << x << "\n";
		}, 5);

																																															/*
	[ 참조로 인자 전달 (주의: 반드시 std::ref) ]
																																																	*/
	void update(int& x) {
		x += 1;
	}

	int val = 10;
	std::thread t(update, std::ref(val)); // std::ref 없으면 복사됨!

																																																/*
	[ 멤버 함수 호출 ]
																																																	*/
	class Worker {
	public:
		void run(int id) {
			std::cout << "Worker " << id << "\n";
		}
	};

	Worker w;
	std::thread t(&Worker::run, &w, 1); // 객체 포인터 &w 전달


																																																	/*
	[ 함수 객체 (Functor) ]
																																																	*/
	struct Task {
		void operator()(int a) {
			std::cout << "Task with " << a << "\n";
		}
	};

	std::thread t(Task(), 42);

																																																		/*
	[ 가변 인자 함수 ]
																																																	*/
	void print_all(const std::string& a, int b, double c) {
		std::cout << a << ", " << b << ", " << c << "\n";
	}

	std::thread t(print_all, "score", 100, 3.14);



//-----------------------------------------------------------