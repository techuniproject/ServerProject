																																																																																																																																																	/*

	[Youtube 쉬운코드 : 네트워크 강의 정리]

	1) 네트워크란 무엇인가?
	

	 [인터넷 연결하고 싶을 때]

	 1. IP주소
		-> 인터넷에 연결되기 위해 필요한 인터넷 상의 식별 주소
		-> 네트워크 상에서 컴퓨터를 식별하기 위한 고유 주소

	 2. 모뎀(modem)
	    -> 네트워크 통신에 필요한 신호 변환 장치
		-> Internet에 케이블을 통해 연결하여 공유기에 연결함.

	 3. 공유기 (home router)
	    -> 여러 기기들을 인터넷에 연결될 수 있도록 하는 장치
		-> 하나의 IP주소로도 동시에 인터넷을 사용 가능하게하는 장치
		-> 공유기에 연결된 기기들은 같은 네트워크 소속
        -> 같은 공유기에 연결된 장치들은 하나의 네트워크 구축(LAN) - 인터넷 필요 X

	 4. 스위치 (Switch)
	    -> 같은 네트워크 내의 기기들이 서로 통신할 수 있도록 하는 장치
		-> 보통 공유기의 LAN 포트 수가 부족할 때 사용 (공유기에도 스위치 기능이 있다는 뜻)
		-> 스위칭 허브 혹은 그냥 허브라고 불리는데 옛날의 허브개념과는 다름

	 5. 네트워크 (Network)
	    -> 컴퓨터나 기타 기기들이 리소스를 공유하거나 데이터를 주고 받기 위해
		    유선 혹은 무선으로 연결된 통신 쳬계

	   [1] LAN (Local area Network)
	    -> 집, 학교, 회사 등 제한된 범위 내에서 컴퓨터나 기타 기기들을 연결하여
		    데이터나 리소스를 공유할 수 있게 하는 네트워크
		-> ex) Ethernet (유선 통신을 담당하는 LAN) , wireless LAN - WIFI (무선 통신 LAN)
	   
	   [2] WAN (Wide area Network)
	    -> 여러 LAN이나 다른 종류의 네트워크들을 하나로 묶어서 멀리 떨어진 
		    기기들도 통신이 가능하도록 만든 네트워크
		-> 훨씬 더 넓은 범위를 커버하는 네트워크
		-> ex) 은행의 ATM, wireless WAN(4g, 5g), Internet (LAN + Internet 환경 상태)

	6. 인터넷 (Internet)
	   -> 네트워크들의 네트워크
	   -> 세계에서 가장 넓은 영역을 차지하는 WAN
	   -> Global Network라고도 불림

	  [1] ISP (Internet Service Provider)
	   -> 일반 사용자나 회사, 기관 등이 인터넷을 사용할 수 있도록 인터넷 연결 서비스를 제공하는 존재.
	   -> 우리나라 치면 KT, U+, SKT

	   [다른 ISP끼리 어떻게 통신할까?]
	   -> 인터넷은 여러 ISP끼리 네트워크 구축이되어 있다.
	   -> ISP는 티어로 나뉜다.

	   1) Tier 1
	    -> 국제 범위의 네트워크 보유
	    -> 인터넷의 모든 네트워크에 접근 가능
	    -> 인터넷 중추 역할 (backbone)
	    -> 트래픽 전송 비용이 없음 (모든 네트워크에 접근 가능하여 상대적으로 갑의 위치)

	   2) Tier 2
	    -> 국가/지방 범위의 네트워크 보유 (KT,U+,SKT는 여기에 해당)
		-> 일반 사용자나 기업 대상 서비스
		-> 인터넷의 모든 영역과 통신하기 위해 Tier1 ISP에 비용을 내고 트래픽 전송

	   3) Tier 3 (우리나라는 거의 없음)
	    -> 작은 지역 범위 서비스 제공
		-> 일반 사용자나 기업 대상 서비스
		-> 상위 ISP에게 비용을 내고 인터넷 트래픽 비용 지불
	
	7. 라우터 (Router) - ISP 네트워크 간 어떻게 연결되는 걸까?
	  -> 목적하는 네트워크에 데이터를 보내는 장치.
	 
	8. 노드 (Node)
	  -> 네트워크를 이루는 장치
	  -> Router나 스위치 등은 네트워크를 구축하는 장치인 노드

	   [End System or Host]
	   -> 네트워크의 끝에 있는 노드
	   -> 네트워크를 사용하기 위해 연결된 노드
	   -> 클라이언트와 서버로 나뉨.

	   1) 클라이언트 (Client)
	    -> 다른 호스트의 데이터나 리소스를 요청하는 호스트
	   
	   2) 서버 (Server)
	    -> 다른 호스트에게 서비스를 제공하는 호스트
		-> 요청에 따라 데이터나 리소스를 제공
//--------------------------------------------------------------------------------------------------------------------------------------------------------------

	2) Protocol & OSI Layer 7

	[네트워크의 기능]
	  -> 애플리케이션 목적에 맞는 통신 방법 제공
	  -> 신뢰할 수 있는 데이터 전송 방법 제공
	  -> 네트워크 간의 최적의 통신 경로 결정
	  -> 목적지로 데이터 전송
	  -> 노드 사이의 데이터 전송
	
	- 네트워크에서 노드간 통신 기능이 제대로 동작하기 위해서는 참여자들 사이에서 약속된
	   통신 방법이 있어야 한다.

	 1. Network Protocol
	  -> 네트워크 통신을 하기 위해서 통신에 참여하는 주체들이 따라야 하는 형식, 절차, 규약

	 [네트워크의 기능들을 단 하나의 프로토콜로 구현할 수 있을까?]
	  -> 없다!
	  -> 모듈화가 필요하다 (기능별로 분리하여 구현)

	 [어떻게 네트워크 기능들을 분리하여 모듈화하지?]
	 - 애플리케이션 목적에 맞는 통신 방법 제공 : 어플리케이션 사이에서 필요한 기능이네?
	 - 신뢰할 수 있는 데이터 전송 방법 제공 : 어플리케이션 사이에서 어떻게 안정적으로 데이터를 보낼까?
	 - 네트워크 간의 최적의 통신 경로 결정 
	 - 목적지로 데이터 전송 : 호스트 사이에서 어떻게 하면 실제로 목적지까지 데이터를 보낼까?
	 - 노드 사이의 데이터 전송 : 여러 노드 간 데이터를 어떻게 보낼까?
	
	  => 각 기능이 계층별로 동작하는 것 같네? 

	   === Layered Architecture(계층 구조) ===
	 
	 [1] OSI Model (7-layer) 
	  -> 범용적인 네트워크 구조
	  -> 각 레이어에 맞게 프로토콜이 세분화되어 구현
	  -> 각 레이어의 프로토콜은 하위 레이어의 프로토콜이 제공하는 기능을 사용하여 동작
	  
	  ==== [낮은 계층 -> 높은 계층] ===
	 
	 1. Physical Layer (물리 계층) L1
	  -> 비트 단위로 데이터 전송
	
	 2. Data Link Layer (데이터링크 계층) L2
	  -> 직접 연결된 노드 간의 통신 담당
	  -> MAC 주소 기반 통신 (장치와 장치 사이의 통신을 위해 장치 고유 식별 주소 MAC 사용)
	  -> ARP 프로토콜로 IP주소 기반 장치들은 MAC주소로 변환 후 사용

	 3. Network Layer (네트워크 계층) L3
	  -> 호스트 간의 통신 담당 
	  -> 목적지 호스트로 데이터 전송 (IP주소 활용하여)
	  -> 다른 네트워크로 데이터를 전송하기 위한 최적의 경로 선택과 라우팅을 수행
	  -> 대표적으로 IP 프로토콜이 해당 계층에 속함
	  -> 네트워크 계층은 라우터간 경로를 담당하지, 라우터 간 통신 방법엔 관심사가 없으므로 데이터 링크
	      계층에서 구현한 기능으로 경로 선택 기능 구축

	 4. Transport Layer (전송 계층) L4
	  -> 애플리케이션 간의 통신을 담당
	  -> 목적지 애플리케이션으로 데이터 전송
	  [애플리케이션 간 통신 방법에 따라]
	   [1] TCP - 순서 보장 및 안정적이고 신뢰할 수 있는 데이터 전송 보장
	   [2] UDP - 순서 보장 X, 데이터 유실 가능성 있지만, 데이터 전달하는 기능하는 전송
	  -> 전송 계층은 어떤 통신 방법을 사용할 것인지에 관심을 두고, 데이터가 목적지까지 어떻게 찾아갈 것인지는 관심 X.
	      Network Layer가 어떻게 데이터를 보낼지를 담당하며 Transport Layer는 그 기능을 사용해서 어떤 방식으로 애플리케이
		  션까지 전달할것인지 관심. (아래 계층 기능을 이용하여 자신의 계층 기능 구현)

	5. Session Layer (세션 계층) L5
	  -> 애플리케이션 간의 통신에서 세션을 관리
	  -> 양 끝단의 응용 프로세스 간의 대화 제어와 동기화를 담당
	  -> RPC(Remote procedure call)

	 6. Presentation Layer (표현 계층) L6
	  -> 애플리케이션 간의 통신에서 메시지 포맷 관리
	  -> 데이터를 응용 프로그램이 이해할 수 있는 형태로 변환
	  -> 통신 간 인코딩 - 디코딩 / 암호화 - 복호화 / 압축 - 압축풀기 처럼
	       보내는쪽과 받는쪽 포맷을 맞추는 단계이다.

	 7. Application Layer (응용 계층) L7
	  -> 애플리케이션 목적에 맞는 통신 방법 제공
	  -> 사용자가 사용하는 애플리케이션과 직접 상호 작용
	  -> HTTP, DNS, SMTP, FTP 등의 프로토콜 사용
	  -> 이 계층은 어플리케이션 간의 통신 방법에 대한 관심사가 있지, 어떻게 보내는지는 관심이 없으며
	      그건 하위 계층에서 처리할 문제이고, 구현된 기능을 사용하는데 초점.


     [OSI 7 Layer 통신 예시]


     [Computer1]                     [Router]                   [Computer2]
  Application Layer			<----------------------->         Application Layer
  Presentation Layer		<----------------------->		  Presentation Layer
    Session Layer			<----------------------->           Session Layer
	Trasport Layer			<----------------------->     	   Trasport Layer
	Network Layer	<----->	   ^   Network Layer   |	<----->	 	Network Layer		         
   Data Link Layer	<----->	   |  Data Link Layer  | 	<----->	 	Data Link Layer		           
    Physical Layer  <----->	   |    Physical Layer v	 <----->	 	Physical Layer	

	[컴퓨터 1 -> 컴퓨터 2]
	-> 컴퓨터 1의 7->1까지 포장되어 물리계층간 라우터로 이동하여 
	    라우터의 프로토콜에서 NetworkLayer까지 올려 분석 후 다시 Computer 2로
	     보내기 위해 다시 물리계층으로 재포장 후 컴퓨터 2의 물리계층에서부터 7까지 수행


	 [2] TCP/IP Stack (4-layer)
	  -> 인터넷에 특화된 네트워크 구조 (실제 사용되는 모델)

	  1. Application Layer

	  2. Transport Layer

	  3. Internet Layer
	   
	  4. Link Layer

	  - Transport + Internet + Link Layer (시스템)
	  -> 하드웨어, OS 레벨에서 구현 및 관리
	  -> 네트워크 기능을 지원하는데 목적

	  - Application Layer (애플리케이션)
	  -> 애플리케이션 레벨에서 구현 및 관리
	  -> 네트워크 기능을 사용하는데 목적

	  1. Port
	   - 애플리케이션(프로세스)과 시스템 사이에 통로 역할을 하는 data path
	   - 여러 프로세스 간 포트를 Port name을 통해 식별 (OS마다 식별하는 방법 다름) 
	 
	  2. 인터넷 프로토콜 (과거 1970년대)
	   - 다른 네트워크 상의 두 컴퓨터 간 데이터를 주고받을 때 인터넷 프로토콜을 사용
	   - 인터넷 프로토콜은 unreliable 즉 데이터가 유실 가능성이 있고, 순서보장 X
	   - 그러나 응용프로그램 간 데이터는 안정적으로 주고 받을 수 있어야함.
	   - 그렇게 새로운 프로토콜이 등장하여 TCP(Transmission control protocol)이 등장
	   - TCP는 인터넷 프로토콜 위에서 동작하는 프로토콜
	 
	 [TCP 용어들]
	  [1] Connection : 프로세스 간의 안정적이고 논리적인(물리적인과 반대) 통신 통로

	 -> TCP 통신에서 connection을 열고 (이 때 3-way handshake 발생), 이 connection 위에서
	     데이터를 주고 받고, connection을 닫는다 (이 때 4-way handshake가 발생)
	 -> 이렇게 이루어지는 데이터 전송을 connection-oriented로 칭함

     [인터넷 상에서 어떻게 port를 유니크하게 식별할까?]	  
	  -> port (number) 정의 : 16비트로 이루어짐 (0~65535) / 포트라고하면 이 포트넘버를 많이 떠올림
	  -> 포트넘버만으로는 유니크하게 식별할 순 없음 (범위가 작음)
	  -> 인터넷 주소로 각 host를 유니크하게 식별할 수 있음 -> IP주소로
	  -> 그러면? IP주소 + port number합치면 유니크하네?

	 3. Socket
	  -> IP주소와 Port Number을 합쳐 인터넷 상에 존재하는 각 port를 유니크하게 식별하기 위한 주소
	  -> 각 socket은 인터넷 상에서 유니크함을 보장.

	[TCP Connection & Socket]
	 -> 각 connection을 유니크하게 식별할 수 있어야 한다
	 -> 한 쌍의 socket(전달&받는쪽)으로 connection을 유니크하게 식별하기 때문.
	 -> <src IP addr , src port, dest IP addr, dest port> 로 connection 구별
	 -> 하나의 socket은 동시에 여러 connection들에 사용될 수 있음.

	 4. UDP (User datagram Protocol)
	  -> Connectionless protocol : 연결을 맺지 않고 바로 데이터를 주고 받음.
	  -> unreliable : 인터넷 프로토콜을 거의 그대로 사용하기 때문
	  -> connection이 없다보니 socket이라는 단어를 사용하지 않다가 요즘엔 사용
	  -> UDP등장으로 이제 소켓간 통신에서 프로토콜까지 구별하는 칸을 만들어 구별 <protocol, ip addr, port number>로 유니크하게 식별


//---------------------------------------------------------------------------------------------------------
      
	   1. 네트워크 프로그래밍 관점에서 Socket

	   -> TCP/IP 모델에서 애플리케이션 계층이 시스템 계층의 기능을 함부로 쓸 순없다.
	   -> 대신 시스템은 애플리케이션이 네트워크 기능을 사용할 수 있도록 프로그래밍 인터페이스를 제공함
	   -> 애플리케이션은 socket을 통해 데이터를 주고 받는다.
	   -> 개발자는 socket 프로그래밍을 통해 네트워크 상의 다른 프로세스와 데이터를 주고 받을 수 잇도록 구현

	   -> 대부분의 시스템은 socket 형태로 네트워크 기능 제공
	   -> 보통 개발자가 socket을 직접 조작해서 통신 기능을 구현할 일은 적다
	   -> 애플리케이션 Layer의 프로토콜은 보통 라이브러리나 모듈 형태로 해당 기능이 제공되는데,
	       이때 내부를 열어보면 소켓을 활용해서 프로토콜을 구현했음을 알 수 있음

	   [실제 구현/동작 관점]

	   - port는 socket을 식별하기 위해 부여되는 숫자

	   - socket은 <protocol, IP address, port number> 로 정의
	   - ex) socket(AF_INET, SOCK_STREAM, 0)
	        sockaddr.sin_family = AF_INET;
	        sockaddr.sin_addr.s_addr = inet_addr("111.0.0.2");;
	        sockaddr.sin_port = htons(8080);
			bind(sock,(SOCKADDR*)&sockaddr,sizeof(sockaddr));

	   -> 표준에서 소켓을 저렇게 정의하면서 실제로 달라진 부분이 있다.
	   -> socket은 <protocol, IP address, port number>로 식별되는데 이게 유니크하게 되냐?
	   -> UDP는 유니크하게 식별됨 / TCP는 유니크하게 식별안됨

	   1) 서버와 클라에서 TCP가 유니크하게 식별되는 과정!!
	    서버 <50.50.50.50, 8080> / 클라 <77.77.77.77, 49999>

	    1. connection 맺는 요청을 기다리는 listening socket이 존재 ->listen()함수
		2. connection이 맺어지면(3-way handshake로) listening socket이 또 다른 socket을 만듦 -> 클라(connect())로 connection하면
		3. accept()함수를 호출함으로써 그 다르게 만든 소켓과 클라의 소켓이 connection을 형성
		4. 그렇게 추가적으로 만들어진 소켓은 IP주소와 포트넘버가 모두 동일
		5. 그러면 어떻게 소켓을 식별하지?
			[connection 연결 여부로]
		 - connection전 연결 요청시(connection 없으면) - listening socket으로 전달 
		 - connection 성립 이후 <src IP, src port, dest IP, dest port>로 리스닝이 아닌 다른 소켓으로 식별
		
		6. 그러면 클라이언트 쪽에서도 같은 IP와 port를 가지는 서로 다른 TCP 소켓이 생길 수 있을까?
		 - YES : 클라는 OS레벨에서 ip(ip는 같은 컴에선 같으니까)와 port를 알아서 할당하는데 
		      -> port번호를 사용하지 않은 번호를 할당하는데, 너무 많은 port를 할당하여 이제 다 점유되었으면
			      중복된 port할당(더 많은 조건이있지만 가능하다는 말)
		 - 이 경우엔 이미 같은 IP Port간 특정 서버와 연결을 맺었으면 해당 클라 소켓은 연결을 못함.

		 [결론] src 와 dst 간 IP와 port의 짝으로 어떤 소켓인지 구별.

		2) UDP에서 Socket 동작 방식

		- 여기는 커넥션이 없어 
		- <src ip, src port, dest ip, dest port> 정보로 상대구분

		
//------------------------------------------------------------
		[포트넘버]
		- 0~1023은 well-known ports
		ex) HTTP(80), HTTPS(443), DNS(53)
		
		- 1024~49151 : registered ports (IANA에 등록된 번호)
		ex) MYSQL DB(3306)

		- 49152 ~65535 : dynamic ports (등록 안된 번호, 운체가 임시로 혹은 자동 할당할 때 사용)

				
																																																																																																														*/