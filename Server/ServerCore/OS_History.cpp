/*
[운영체제의 역사]
운영체제는 컴퓨터가 처음 생길 때부터 있지 않았다.

<<전자식 디지털 컴퓨터 시대 - 초기 컴퓨터 출현 -> 운영체제의 탄생까지>>
<고정 프로그램 컴퓨터(1940년대)> ex) ENIAC

컴퓨터의 모든 기능을 하드웨어로 만드는 시절, 소프트웨어 개념X, 운영체제 개념X
하나의 프로그램을 컴퓨터 기계에 굳히는 방식
- 실행하고자 하는 작업(Job, 오늘날의 프로그램)을 종이에 스케치 후, 하드웨어 스위치를 위아래로 세팅하거나 전선에 직접 연결하는 방법
=> 컴퓨터 자체가 하나의 프로그램(한 개의 프로그램을 하드웨어로 고착화시키는 프로그래밍 방식)
	- 해당 컴퓨터는 오직 해당 프로그램만 실행 가능, 다른 프로그램을 실행하려면 전선을 해체하고 다시 스위치를 조작하고 전선을 연결해야만 한다.
	- 여기서 프로그램 디버깅은 컴퓨터 하드웨어에서 잘못 연결된 전선을 찾는 것을 의미
=> CPU와 메모리의 개념이 분리X, 프로그램을 저장 장치에서 메모리에 적재하여 실행시키는 개념X
   (오직 배선판에 전선을 연결하여 프로그램을 기계에 고착시키는 고정 프로그램 방식의 컴퓨터)

<내장 프로그램 컴퓨터(1945년)>
컴퓨터를 하드웨어와 소프트웨어로 분리
컴퓨터 하드웨어는 그대로 두고 실행을 원하는 프로그램을 메모리에 적재한 후 CPU가 실행하는 방식
이 후 모든 컴퓨터는 내장 프로그램 방식으로 만들어지게 되어 오늘날까지 사용되고 있음.



+ 내장 프로그램
컴퓨터의 구조를 CPU와 전자식 메모리로 분리,
프로그램의 명령(코드)들을 전자식 메모리에 적재하고 , CPU가 메모리에서 명령들을 하나씩 CPU 내부로 가지고 와서 처리하는 새로운 방식의 컴퓨터 개념
내장 프로그램 컴퓨터를 사용하면, 실행시키고자 하는 여러 개의 프로그램이 있을 때, 전자식 메모리에 한 번에 하나씩 프로그램을 적재하고 CPU에게 프로그램을 실행하도록 지시하기만 하면 된다.

내장 프로그램 컴퓨터의 구조
- CPU(제어 장치, 연산 장치, 레지스터들로 구성)
	- 제어장치: 메모리에서 명령을 읽어오고, 해석하고, 연산장치에서 명령에 지시된 연산을 수행하도록 제어
	- 연산장치: 덧셈, 뺄셈, 곱셈, 나눗셈의 산술 연산과 논리곱(and), 논리합(or), 논리부정(not)의 논리 연산을 처리하는 하드웨어
	- 레지스터: 연산을 실행하는 동안 명령과 데이터를 일시 저장하는 저장소

- 메모리 내의 명령이나 데이터는 주소로 엑세스
- CPU 레지스터
	- PC (Program Counter)
		- 다음에 실행할 명령어의 메모리 주소 저장
		- 명령어를 순차적으로 실행하기 위해 주소 기억
	- MAR(Memory Address Register)
		- PC에 저장된 주소를 메모리로 전달하는 역할
		- 메모리에서 데이터를 가져오기 위한 주소 출력용 레지스터
	- MDR(Memory Data Register)
		- 메모리로부터 읽어온 명령어 또는 데이터를 임시로 저장
		- 제어장치가 메모리에서 읽은 값은 먼저 이곳에 저장된다.
	- IR(Instruction Register)
		- MDR에 저장된 명령어가 이동하여 저장되는 레지스터
		- 즉, 현재 실행할 명령어를 저장하고 해석
	- AC(Accumulator Register)
		- 계산에 사용될 데이터 또는 연산 결과를 저장
		- 주로 연산 장치(ALU)와 연계되어 동작

	- 흐름도
		1. PC → 다음 명령어 주소 보관
		2. 주소 → MAR → 메모리 접근
		3. 메모리 내용 → MDR (임시 저장)
		4. 명령어 → IR (실행 준비)
		5. 계산 결과 ↔ AC

		┌────────────┐
		│   PC					  │   ← 다음 명령어 주소 저장
		└────┬───────┘
			 │
			 ▼
		┌────────────┐
		│   MAR				  │   ← 주소를 메모리에 전달
		└────┬───────┘
			 │
			 ▼
		┌────────────┐
		│  Memory				  │   ← 명령어 또는 데이터 읽기
		└────┬───────┘
			 │
			 ▼
		┌────────────┐
		│   MDR				  │   ← 메모리에서 읽어온 값 임시 저장
		└────┬───────┘
			 │
			 ├─────────────┐
			 │                          ▼
			 │				 ┌────────────┐
			 │				 │    IR				   │   ← 읽어온 값이 명령어인 경우, 제어장치가 해석
			 │				 └────────────┘
			 │
			 ▼
		┌────────────┐
		│    AC				  │   ← 계산에 필요한 값 or 계산 결과 저장
		└────────────┘

<프로그램 로더 - 운영체제 개념 시작(1950년대)>
+ IBM 701
	- IBM에서 만든 첫 번째 내장 프로그램 방식의 메인 프레임 컴퓨터
	- 대여만 가능했던 해당 컴퓨터는 대여시 하드웨어와 메뉴얼만 주고 다른 어떠한 소프트웨어도 주지 않았다.
	- 이 당시에는 운영체제 개념 X, 라이브러리 개념 X
	- 개발자가 [목적 프로그램 + 해당 프로그램을 적재하는 코드]를 작성해야만 했다.

로더
- 목적 프로그램을 읽어들이는 코드
- 해당 프로그램이 모든 컴퓨터와 개발자들에게 공통적으로 필요했다.
- 유사한 "로더"를 작성하는 것이 엄청난 시간 낭비
- 해당 개념이 오늘날 운영체제로 발전하는 계기가 되었다.

<원시 운영체제 GM OS(1955년)>
GM(General Motors)
- IBM 701 고객이 개발
- 펀치 카드에 담긴 프로그램을 메모리에 적재하는 로더 프로그램
- 로더 프로그램을 테이프에 저장해두고 필요할 때 실행시켜 사용자 프로그램(펀치 카드에 작성된)을 메모리에 적재시킴.
- 해당 로더를 GM -> Monitor -> GM OS(General Motors Operating System)라고 불렀다.
- 최초의 원시 운영체제

=> 자가 로더를 작성할 필요 없이 목적 프로그램만 작성하면 되었다.

- 활용 방법
	- 1. 개발자는 컨트롤 패널에서 테이프 장치에 저장된 로더 프로그램을 메모리에 적재 후 실행
	- 2. 로더 프로그램은 사용자 프로그램을 메모리에 적재
	- 3. CPU가 사용자 프로그램을 실행시킴.

<최초의 운영체제 GM-NAA I/O(1956 ~ 1957년>

+ IBM 704
	- IBM 701의 처리 속도를 2배 정도 높임.
	- IBM 701 문제점 3가지
		- 1. 여전히 대기표를 뽑고 자신의 차례 대기
		- 2. 프로그램을 실행시킬 때마다 여러 장치를 점검하고 컨트롤 패널의 스위치를 조작해서 컴퓨터 시스템 설정을 반복
		- 3. 카드 입력 장치나 테이프 장치를 제어하는 프로그램 코드는 개발자가 작성해야 함.

GM-NAA I/O 소프트웨어
- IBM 704에서 사용할 최초의 운영체제
- GM이 만들어 놓은 로더 프로그램 확장
- 개발자의 작업들을 한 번에 하나씩 순서대로 메모리에 적재하고 실행(일종의 배치 운영체제)

=> 프로그램 개발자와 관리자 분리

GM-NAA I/O 운영체제의 구조와 동작
- 3가지 코드로 구성
	- 어셈블러 코드: 사용자가 작성한 어셈블리어 프로그램을 기계어 코드로 번역
	- 로더 프로그램: 사용자 프로그램을 메모리에 적재
	- 운영체제 메인 코드와 공통 입출력 코드: 운영체제 시작 코드와 장치 입출력을 다루는 프로그램 코드

- 컴퓨터가 시작될 때 메모리에 적재되어 컴퓨터가 종료할 때까지 메모리에 상주

- 작동 방식
	- 1. 관리자는 사용자들이 제출한 모든 프로그램들(펀치카드들)을 카드 입력 장치를 이용하여 테이프 장치로 읽어 들여 실행 준비 완료
	- 2. GM-NAA I/O 운영체제는 테이프 장치에 적재된 사용자 프로그램을 한 번에 한 개씩 모두 실행
		- 1. '메인 코드': 자기 테이프에 저장된 프로그램 중 하나를 메모리에 읽어들임.
		- 2. '어셈블러 코드'를 활용하여 기계어 목적 코드로 만들어 테이프 장치에 저장
		- 3. '로더 프로그램'을 이용하여 목적 코드를 메모리에 적재
		- 4. 프로그램이 실행되는 동안 컴퓨터의 사용 시간과 자원 사용량을 저장
		- 5. 프로그램의 실행이 끝나면 해당 정보와 프로그램이 출력한 결과를 함께 사용자에게 제공(프린트에 출력해서)

- 라이브러리 개념 등장
	- 응용 프로그램 개발자들이 공통으로 필요한 코드를 표준화하여 라이브러리 형태로 제공
		ex) 10진수 -> 2진수, 2진수 -> 10진수

- 문제점 3가지 해결
		- 하나씩 연속하여 프로그램을 적재시키고 실행
			해결: 대기표를 뽑고 자신의 차례 대기 및 컴퓨터 장치 점검 및 시스템 설정을 반복

		- 테이프 장치나 프린터 장치 등 입출력 장치를 제어하는 코드 포함 -> 더 이상 입출력 장치 제어 코드 작성하지X
		- 해당 코드를 필요할 때 자신의 프로그램에 호출하면 되었다.
			해결: 카드 입력 장치나 테이프 장치를 제어하는 프로그램 코드는 개발자가 작성

=> GM-NAA I/O 운영체제는 모든 응용 프로그램이 공통적으로 필요로 하는 I/O 작업을 수행하는 코드를 메모리에 상주시켰기 때문에 I/O System이라고 불렀다.
	- 오늘날 운영체제의 장치 관리 기능, 프로그램 적재 및 실행 기능, 대기 중인 작업들을 하나씩 적재하고 실행시키기 때문에 최초의 운영체제


<운영체제 탄생 과정 요약>
1. 기계식 컴퓨터
2. 전자식 디지털 컴퓨터 출현
3. 전자식 고정 프로그램 방식의 컴퓨터
4. 폰노이만의 내장 프로그램 컴퓨터 제안
5. IBM 701 내장 프로그램 컴퓨터
6. 프로그램을 적재하고 실행시키는 로더 프로그램의 필요성 인식
7. 원시적인 운영체제 GM OS(모니터) 개발
8. 최초의 운영체제 GM-NAA I/O 탄생

<<운영체제의 발전>>

<초기 운영체제 시작>
- 컴퓨터 활용률이 매우 낮았음.
	- 개발자가 컴퓨터를 셋업하는 시간 동안 컴퓨터가 놀게 되었음.
	- 컴퓨터 하드웨어의 발전으로 메모리 및 CPU 처리 속도가 높아졌다.
	- 컴퓨터 활용률을 높이기 위해 GM-NAA I/O와 같은 초기 형태의 배치 운영체제가 개발되었음.

<배치 운영체제>
- 개발자와 관리자가 구분
- 출현 배경
	- 초기 운영체제는 컴퓨터 작동 시간 < 셋업 시간
		- 컴퓨터 활용률을 높이기 위해 개발되었다.
+ 배치
	- 개발자가 작성한 펀치 카드 묶음
	- 배치 = 배치 작업의 줄임말
	- 하나의 프로그램
+ 배치 처리
	- 배치 운영체제로 작업을 처리하는 방식
	- 여러 배치 작업들을 모아서 한꺼번에 실행하되 한 번에 한 개씩 순차 실행, 비대화식, 프린트로 결과 출력, 결과는 작업 요청 한참 뒤에 받을 수 있음.
- 배치 처리 과정
	- 개발자는 손으로 작성한 프로그램을 펀치 카드에 입력 후 입력 데크에 올려놓고 관리자가 실행해주기를 기다린다.
	- 관리자는 입력 컴퓨터를 작동시켜 여러 배치를 읽어 테이프 장치에 저장한다.
	- 관리자가 컴퓨터를 작동시키면, 배치 운영체제가 실행되어 자동으로 테이프 장치에 들어있는 배치 작업을 메모리로 읽어 들이고 실행시킨다.
	  (배치 운영체제는 한 번에 하나씩 작업 처리)
	- 실행 결과는 프린터에 출력

<다중 프로그래밍 운영체제>
- 출현 배경
	- 하드웨어 기술의 발전이 급격하게 이루어짐
		- 하드웨어 속도 개선(cpu, 메모리 등), 컴퓨터 가격 상승
	- 컴퓨터의 처리율을 높이기 위해 CPU를 효율적으로 사용하는 방법 고안
		- CPU의 노는 시간을 최대한 줄여 많은 사용자 프로그램을 실행시키는 방법 필요
	- 하나의 프로그램 실행 과정
		- CPU 작업 - I/O 작업 - CPU 작업 - I/O 작업 -... - 종료
		- 배치 시스템은 한 번에 한 개의 작업만 실행
			- CPU가 프로그램을 실행하다가 IO 작업(파일 읽기, 쓰기, 프린터로 출력)이 발생하면 CPU는 I/O 장치가 I/O 작업을 끝낼 때 까지 놀면서 대기
				- I/O 장치가 CPU에 비해 굉장히 느리기 때문에 I/O가 발생하면 CPU는 엄청난 시간을 낭비하게 된다.
	=> 저조한 CPU 활용률을 극대화하기 ㅜ이해 다중 프로그래밍 기법 제안

- 다중 프로그래밍 기법
	- 여러 프로그램을 메모리에 올려놓고 동시에 실행시키는 기법
	- CPU가 한 프로그램을 실행하다 I/O가 발생하면 입출력이 완료될 때까지 CPU가 메모리에 적재된 다른 프로그램을 실행하여 CPU의 노는 시가능ㄹ 줄임

+ 다중 프로그래밍 정도(DOM: Degree of Multiprogramming)
	- 여러 개의 프로그램을 동시에 실행시키는 기법

- 실행 예시
	시간      : 1   2   3   4   5   6   7   8   9   10  11

	Program A: CPU CPU CPU I/O I/O -   -   -   CPU I/O  -
	Program B: -   -   -   CPU CPU I/O I/O I/O -   CPU  -
	Program C: -   -   -   -   -   CPU CPU CPU I/O I/O  I/O

	=> 메모리에 적재된 프로그램들이 조금씩이지만 모두 동시에 실행되는 셈이다.

- 다중 프로그래밍 운영체제를 가진 컴퓨터 시스템(시스템 구조)
	- 테이프 장치가 더 빠른 하드 디스크 장치로 바뀌었을 뿐 배치 시스템과 모양이 거의 같다.
	- 배치 시스템에서와 동일하게 작동
		- 1. 개발자들은 프로그램을 가져와 입력 데크에 쌓아둠.
		- 2. 관리자가 입력 컴퓨터를 작동시켜 입력 데크에 모인 프로그램을 디스크 장치로 읽어 들임.
		- 3. 디스크 장치에는 실행을 기다리는 여러 프로그램들이 담김.
	- 메모리 크기를 고려하여 디스크 장치로부터 제한된 개수의 프로그램을 메모리에 적재하고 프로그램을 실행
	- 프로그램이 종료될 때마다 디스크 장치에 대기 중인 프로그램 하나를 메모리에 적재하여 실행에 참여시킴.

=> 오늘날 모든 운영체제는 다중 프로그래밍 운영체제
	- CPU 활용률과 작업 처리율이 높아져 배치 시스템에 비해 동일한 시간에 처리할 수 있는 작업의 개수가 많아짐.
	- (여러 프로그램을 실행 가능한)

- 다중 프로그래밍 도입으로 인한 문제점
	- 문제를 해결하는 과정에서 컴퓨터 시스템에 많은 발전이 이루어졌고, 운영체제 이론의 대부분도 이 시기에 형성
	- 문제들
		- 큰 메모리 이슈
			- 여러 개의 프로그램을 동시에 메모리에 올려놓기 위해 메모리 크기를 늘려야 했다.
		- 프로그램의 메모리 할당 및 관리 이슈
			- 여러 프로그램을 동시에 실행하기 위해, 각 프로그램을 메모리의 어디에 적재할 것인지, 프로그램에게 할당할 메모리의 크기가 얼마가 적당한지, 몇 개의 프로그램을 메모리에 적재하는 것이 효율적인지..
		- 메모리 보호 이슈
			- 프로그램이 실행 도중 다른 프로그램에게 할당된 메모리 영역을 침법하지 못하도록 할당된 메모리에 대한 보호 이슈
				- 한 개의 프로그램만 메모리에 적재하던 배치 처리 시스템 때에는 없던 문제
		- CPU 스케줄링과 컨텍스트 스위칭
			- 실행 도중 I/O를 요청하면 운영체제는 프로그램의 실행을 중단시키고 메모리에 적재된 다른 프로그램을 선택하여 실행시키는데
			  이때 메모리에 적재된 어떤 프로그램을 선택할지를 결정하는 CPU 스케줄링 이슈 발생
			- 실행이 중단되는 프로그램의 상태(컨텍스트)를 별도의 공간에 저장해두고, 스케줄링으로 선택한 프로그램의 이전에 저장해둔 상태(컨텍스트)를
			  다시 CPU에 복귀시키는 컨텍스트 스위칭 이슈 발생
		- 인터럽트 개념 도입
			- 운영체제는 I/O 장치로부터 입출력이 완료되었음을 전달받는 방법이 필요해져서 인터럽트 개념 도입
		- 동기화
			- 다중 프로그래밍으로 인해, 여러 개의 프로그램이 동시에 실행되면서 동일한 자원을 동시에 사용하는 문제 발생
				ex) 프로그램 A가 R 자원 사용(R 자원 상태: S), I/O 발생, 프로그램 B가 R 자원 사용(R 자원 상태: T), 이후 프로그램 A가 실행될 때 문제 발생
					- 자원 R의 상태가 프로그램 B에 의해서 훼손
		- 교착상태 해결
			- 동기화 문제들 중 하나, 자원이 소유한 프로그램들 사이에 다른 프로그램이 소유한 자원을 서로 요청하면 자원을 획득할 때까지 서로 무한정 대기하는 교착상태 발생
				ex) 프로그램 A와 프로그램 B가 각각 자원 R1, R2를 소유한 상태에서 프로그램 A는 R2을 요청, 프로그램 B는 R1을 요청하면 두 프로그램을 무한정 대기하는 교착상태에 빠짐.

<시분할 다중프로그래밍 운영체제>
- 적재된 여러 프로그램을 시간 단위로 나누어 번갈아 실행하는 다중 프로그래밍 기법
- 시분할 운영체제는 배치 처리와 다중 프로그래밍 처리에 있는 문제점을 해결하고자 함.
	- 문제점
		- 비대화식 처리방식
			- 여러 프로그램(작업)들이 특정 시간에 모두 처리되며 프로그램 실행 결과도 한참 후에 받게되는 방식
		- 느린 응답 시간과 오랜 대기 시간
			- 프로그램이 실행되는 중간 결과에 대해 사용자의 즉각적인 대응이 불가능, 프로그램을 제출하고 출력된 종이로 받는데 오랜 시간이 걸림.

- 원격 대화식 시스템 제안
	- MIT 대학의 John McCarty 교수는 다중 프로그래밍 시스템에서 프로그램을 작성하면서 디버깅에 너무 많은 시간이 소요됨에 큰 불편함을 느낌.
		- 원격, 대화식 시스템을 제안
			- 대화식 운영체제(사용자에게 빠른 응답을 제공하고 사용자가 즉각적인 대응을 할 수 있는)
			- 대화식으로 프로그램을 실행시키기 위해 원격으로 컴퓨터에 접속 원격 시스템 제안
	- 원격 시스템
		- 사용자가 키보드와 모니터, 모뎀과 전화선을 갖춤.
		- 전화선을 이용하여 원격에서 컴퓨터에 접속하며 프로그램의 출력 겨로가를 디스플레이 모니터에 출력(기존 방식: 프린트 용지)
			- 사용자는 원격에서 컴퓨터를 접속한 뒤 프로그램의 실행을 요청하고, 프로그램이 출력하는 결과를 전송받아 자신의 모니터에서 즉각적으로 확인하고 다시 명령을 내리도록 제안
	- 해당 시스템을 시분할 시스템이라고 불렀음.


- 시분할 운영체제
	+ 시분할
		- 각 프로그램에게 고정된 시간만큼 CPU를 할당하여 번갈아 실행시키는 기법
	- 일정 시간 간격으로 돌아가면서 프로그램에게 CPU를 할당
	- 사용자의 키 입력 속도에 비해 컴퓨터의 속도가 비교할 수 없을 만큼 빠르기 때문에 시분할 처리 가능
	- 한 번에 처리할 작업량이 적고 사용자가 컴퓨터와 대화식으로 작업을 처리하는 경우 적합
		- 배치 운영체제가 적합할 경우
			- 통계처리와 같이 대화나 입출력 없이 한 번에 많은 시간이 걸리는 작업은 배치 운영체제가 적합
		
	- 여러 개의 프로그램을 메모리에 적재하고 시간 할당량(time slice, 타임 슬라이스)을 정하여 시간 할당량만큼 메모리에 적재된 모든 프로그램에게 돌아가면서 CPU를 할당하고 실행시킴.
		- 시분할(time sharing)은 CPU 사용 시간을 여러 프로그램들에게 나누어 주는데 붙여진 이름
	- 컴퓨터 시스템
		- 터미널은 키보드와 모니터, 모뎀으로 이루어진 간단한 입출력 장치
		- 전화선을 이용하여 메인프레임 컴퓨터에 연결
		- 사용 방식
			- 사용자 개수만큼(터미널 개수) 사용자와 대화하도록 미리 준비된 프로그램을 실행시킴.
			- 이 프로그램은 해당 터미널로부터 사용자의 명령을 받아 명령을 처리하고 결과를 터미널에 출력한 후 사용자로부터 다음 명령을 대기

	- 라운드 로빈
		- 시분할 운영체제에서 각 프로그램에게 동일한 시간 할당량만큼씩 번갈아 실행시키는 스케줄링 기법

	=> 시분할 운영체제는 다중프로그래밍 기법과 대화식 처리, 시분할 스케줄링을 결합하여 여러 프로그램을 동시에 실행시키는 운영체제
		- Unix, Linux, Windows 등 오늘날 대부분의 운영체제가 시분할 운영체제의 기능을 가지고 있다.

<개인용 운영체제>
- 반도체 기술과 컴퓨터 하드웨어의 발전으로 메인프레임 대신 작으면서 성능이 뛰어난 미니 컴퓨터가 대세를 이루었다.
- 미니 컴퓨터
	- 여러 사용자가 동시에 터미널을 이용하여 원격에서 사용하는 다중 사용자 컴퓨터로서 특별한 전문 관리자에 의해 관리되었다.
- 미니 컴퓨터 사용자가 늘어나면서 사용자 응답 속도는 떨어지고, 터미널이 있는 장소에 가야만 컴퓨터를 사용할 수 있는 등 불편함을 느끼기 시작했다.

- 마이크로프로세서의 개발이 개인용 컴퓨터의 도입과 상용화에 결정적인 역할을 했다.

+ 마이크로프로세서
	- 하나의 반도체 칩으로 만들어진 CPU 장치
	- 마이크로프로세서가 개발되기 전에는 많은 IC 칩들을 연결해서 보드 형태로 CPU를 만들었다.
	- 처음 시장에 나온 것은 4004(인텔사에서 만든)로 손가락 한 개 정도의 작은 크기의 칩이지만 ENIAC 컴퓨터 한대와 맞먹는 처리 능력을 가졌다.

- 초기 개인용 컴퓨터는 하나의 보드로 만들어져 미니컴퓨터보다 가격이 싸고 크기가 작어서 인기가 많았으며 마이크로컴퓨터라고 불렸다.
- 그 이후로 고성능 마이크로프로세서들이 개발되어 다양한 마이크로컴퓨터가 탄생하였고 오늘날의 PC로 발전하게 되었다.

- 개인용 컴퓨터의 확산
	- 개인용 컴퓨터가 확산되게 된 것은 개인용 운영체제의 탄생에 있다.
	- MS-DOS
		- CP/M과 QDOS를 바탕으로 빌게이츠가 완성한 개인용 운영체제
		- DOS 이후 1개인용 운영체제는 Window, Mac OS, 리눅스의 3대 운영체제로 시장이 재편되고 이어지고 있다.
	- IBM은 최초의 PC를 만들 때부터 작은 부팅 프로그램을 담은 ROM(Read Only Memory) 메모리를 장착하였다.
		- 이 ROM에 담긴 부팅 프로그램이 PC 하드웨어를 모두 테스트한 후, 디스크 특정 영역에 저장된 MS - DOS 운영체제 코드를 메모리에 적재하도록 하였다.
			- 이 방식은 오늘날 PC에도 여전히 사용되고 있다.
			- ROM에는 하드웨어를 제어하는 기본적인 저수준 코드가 들어있어 해당 프로그램을 BIOS(Basic Input Output System)라고 부른다.

<임베디드 운영체제>
- 임베디드 운영체제는 임베디드 컴퓨터에서 장치들을 제어하고 작동시키는 기능을 수행하며, 장치를 제어하는 프로그램이 원활이 실행되도록 하는데 목적이 있다.
- 종류
	- WinCe.. 등
- 임베디드(내장형) 컴퓨터
	- 자동차, 비행기 제어 시스템, 공장, 디지털 TV, ATM기 등에 내장되어 이들 장치들의 목적을 지원하는 소형 컴퓨터이다.

<모바일 운영체제>
- 하드웨어의 급속한 발전으로 휴대 가능한 크기로 들고 다닐 수 있는 모바일 장치 혹은 모바일 컴퓨터를 만들 수 있게 되었다.
- 스마트폰, 태블릿, 스마트 시계 등과 같은 어디에서나 휴대할 수 있는 다양한 모바일 컴퓨터들이 탄생하였다.
- 모바일 운영체제
	- 모바일 전화기, 스마트폰, 태블릿 컴퓨터 등 다양한 이동용 혹은 휴대용 장치에서 실행되도록 만들어진 운영체제이다.
	- PDA(Personal Digital Assistant)라고 불리는 Palm 탑 컴퓨터에서 시작되었다.
		- 가장 초기의 모바일 운영체제는 Palm OS라고 알려져 있다.

- 다양한 모바일 컴퓨터의 출현과 함께 2003년 Windows Mobile 2003이 출시되고, 연이어 블랙베리, 안드로이드, 아이폰 운영체제들이 출시되었다.
- 현재는 안드로이드, IOS, 블랙베리, Bada, Symbian, Windows Mobile 등 여러 모바일 운영체제가 있지만 2019년 7월 기준 안드로이드의 독식 시장이다.
(2019 7월: 안드로이드(71프로), ios(28프로), Windows Phone OS)

<<운영체제의 종류>>
<데스크톱 운영체제>
- 범용으로 사용된다.
	- ex) 문서 편집, 웹 서핑, 포토샵, 인터넷 활용 등..
- 데스크톱에서 윈도우즈(80 ~ 90프로), 맥 OS(10 ~ 20프로), 리눅스(나머지)가 전체 시장을 지배

<서버 컴퓨터 운영체제>
- 서버 소프트웨어를 실행하는 목적으로, 네트워크에 연결하고 하루 24시간 365일을 중단없이 실행되는 컴퓨터
- 데스크톱 컴퓨터와 달리 사용자들이 원격에서 네트워크로 접속하는 것이 일반적이다.
	- 모니터, 키보드, 마우스, 오디오 등 주변 장치를 가지지 않는다.
	- ex) 웹 서버, 데이터베이스 서버, 파일 서버, 메일 서버 등
- 수많은 사용자가 네트워크로 접속하여 사용하므로, 보안에 매우 엄격하고 컴퓨터 자원을 최적으로 사용하는데 집중되어 있다.
- Linux, FreeBSB, Windows Server, Max OS Server 등이 있다.
- 데스크톱 운영체제와 많은 코드를 공유한다.

<모바일 운영체제>
- 상대적으로 열악한 모바일 장치의 하드웨어를 효율적으로 사용
	- 데스크톱 컴퓨터나 서버 컴퓨터에 비해 메모리나 저장 장치의 크기가 작고 처리 능력이 낮은 cpu
- 이동 중에도 다양한 응용 소프트웨어들이 실행될 수 있는 환경 제공
- 절전 목표
	- 배터리를 주된 전원으로 사용
- 최근 보안 지원에 대한 중요성도 높음.

<임베디드 운영체제>
- 산업 현장의 기계들, 상용 제품 등에 보이지 않게 내장되어 이들 장치들의 작동을 제어하는 컴퓨터
- 임베디드 컴퓨터에서 실행되어 장치들을 제어하고 작동시키는 기능 수행
- WinCE, 여러 종류의 임베디드 Linux
- 장치를 제어하는 프로그램이 원활이 실행되는데 목표를 둔다.

<실시간 운영체제>
- 실시간 응용 프로그램 또는 태스크가 각각 정해진 완료시간(deadline, 마감 시간) 이내에 처리되도록 보장하는 것을 목표로 하는 운영체제
- 윈도우즈나 리눅스와 같은 범용 운영체제와는 구조나 목표가 아예 다르다.
	ex) 비행기를 제어하는 컴퓨터 시스템, 원자력 발전소를 제어하는 컴퓨터 시스템
		- 입력에 대한 정해진 완료시간 내에 반응하도록 구현되어야 한다.
			- 운영체제가 각 태스크에 정해진 데드라인 내에 스케줄하지 못하면 파국이 생긱 수 있다.
- 현재 상용 실시간 운영체제로는 PSOS, Vrtx, RT Linux, Lynx 등
*/