//============2025-07-01==========
#include <iostream>
#include <thread>
#include <chrono>




//========================  [ 스레드 동기화 ] ======================================//
																																																																																	/*
	1. 스레드 동기화의 필요성
	 - 멀티 태스킹은 다수의 작업을 동시에 실행시키는 응용프로그램 작성 기법이다.
	    여러 작업을 동시에 실행시키면 작업 처리의 병렬성을 높여, 응용프로그램의 실행 시간을 단축하거나
		 사용자에게 빠른 응답을 제공할 수 있다.
	 - 한편으로, 다수의 작업들이 공유 데이터에 동시에 접근하면 공유 데이터가 훼손되어 예상치 못한 문제가 발생 할 수 있다.
	 - 공유 데이터에 대한 다수 스레드의 동시 접근을 해결하는 방법이 바로 스레드 동기화이다.

	 정의 : 다수의 스레드가 공유 데이터를 동시에 접근하는 충돌 상황에서 공유 데이터가 훼손되지 않도록 스레드의 실행을 제어하는 기법.
	        -> 뿐만 아니라 작업 순서 보장을 위한 기술과 개념도 포함.

	2. 공유 데이터 문제
	 - 멀티스레드 응용프로그램에서, 다수의 스레드가 공유 데이터에 동시에 접근할 때, 한 스레드가 공유 데이터
	    사용을 마칠 때까지 다른 스레드가 접근하지 못하도록 제어해야 하는데 이것을 스레드 동기화라고 부른다.
	 - 스레드 동기화를 통해 한 스레드가 공유 데이터에 대해 배타적이고 독점적으로 접근하도록 허용되어야 함.



	int counter = 0;

	void increment() {
		for (int i = 0; i < 10000; ++i) {
			++counter; // 공유 데이터에 접근
		}	
	}
																																																																											/*
	[공유 데이터 문제]

	- 멀티스레딩 환경에서는 동시에 읽고 쓰는 작업(read/write) 이 충돌(Race Condition) 을 일으킬 수 있습니다.

	- 두 스레드가 동시에 ++counter를 호출하면, 내부적으로는 다음과 같이 동작합니다
	
	1. 레지스터에 counter 값 로드
	2. +1 수행
	3. 결과를 메모리에 저장
 
	-	이 사이에 다른 스레드가 counter 값을 변경하면, 값이 덮어쓰기 되어 의도한 결과보다 적게 증가할 수 있습니다. 이게 데이터 경쟁(Race Condition) 입니다.


	3. 임계구역과 상호배제
	 - 스레드 동기화는, 공유 데이터를 사용하려고 다수의 스레드가 경쟁하는 경우, 먼저 접근한 스레드가 공유
	    데이터를 배타적으로 사용하도록 다른 스레드가 접근하지 못하게 상호 협력하는 것이다.

	 [1] 임계 구역 (critical section)
	  정의) 사용자가 작성한 프로그램 중 공유 데이터에 접근하는 코드 블록 - 매우 중요한 코드 영역

	 [2] 상호 배제 (mutual exclusion)
	  정의) 다수의 스레드로부터 공유 데이터 접근을 막기 위해, 임계구역은 반드시 
	         한 스레드만 배타적 독점적으로 실행하도록 관리되어야 하는 것.
	  - 상호배제의 핵심은 임계구역에 먼저 진입한 스레드가 임계구역의 실행을 끝낼 때까지 
	     다른 스레드가 진입하지 못하도록 보장하는 것이다.
	  - 임계구역은 반드시 상호배제와 함께 세트로 이루어진다. 상호배제 장치가 없는 임계구역은 있을 수 없다.(위험)

	 * thread-safe 와 thread unsafe *
	  
	   thread-safe : 공유 데이터가 여러 스레드에 의한 동시 접근에도 훼손되지 않게 유지될 때
	       -> 공유 데이터에 대한 스레드의 동기화가 잘 구현되어 있다는 뜻이다.
	 		
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//========================  [ 상호 배제 ] ======================================//
	
	- 상호배제는 멀티스레드가 실행되는 환경에서, 한 스레드가 임계구역 전체를 배타적으로 실행하도록 보장하는 기법이다.
	- 상호배제는 멀티스레드 동기화를 위해 필연적이다.
	- 상호 배제는 스레드 동기화에 포함되는 개념으로, 스레드 동기화에는 공유 데이터 뿐만 아니라 코드 간 순서보장 등이 더 넓은 개념.
	
	1. 상호배제 위치

	--------------------------------
	 일반 코드 (non-critical code)
	  ...
	 임계구역 진입코드 (entry code)
	  ...
	 임계구역 (critical code) - 공유 변수 있는 곳 
	  ...
	 임계구역 탈출코드 (exit code)	
	  ...
	 일반 코드 (non-critical code)
   ---------------------------------

    [1] 일반 코드 (non-critical code)
	 - 멀티스레드 응용프로그램에서 공유 데이터를 액세스하지 않는 코드 부분

    [2] 임계구역 진입코드 (entry code)
	 - entry code는 임계구역에 진입하기 전 필요한 코드 블록으로, 현재 임계구역을 이미 실행중인
	    스레드가 있는지 검사하고, 없는 경우 다른 스레드가 들어오지 못하도록 조치를 취한다.
	 - 만일 임계구역에 이미 진입한 스레드가 있다면 진입한 스레드가 임계구역 실행을 끝내고 
	    exit 코드를 실행할 때까지 현재 스레드를 대기시킨다.

	[3] 임계구역 탈출코드 (exit code)
	 - exit 코드는 스레드가 임계구역 실행을 마칠 때 실행되어야 하는 코드 블록으로, 
	    entry 코드에서 대기 중인 스레드가 임계구역에 진입할 수 있도록 entry 코드에서 취한 조치를 해제한다.

	[4] 임계구역 코드 (critical section)
	 - 임계구역은 공유 데이터에 접근하는 코드 블록으로, 한번에 한 스레드만 실행하도록 보장되어야 하는 코드 부분.
	 - 임계구역은 짧을수록 좋기 때문에, 공유 데이터를 액세스하는 최소한의 코드를 임계구역으로 만드는 것이 바람직하다.


	2. 상호배제 구현
	 - 임계구역에 대한 상호배제는 임계구역에 오직 한 스레드만 들어가게 하는 방책이다.
	 - 구현은 두가지 소프트웨어적 방법과 하드웨어적 방법이 있지만, 소프트웨어적 방법은 한계가 있어 하드웨어적 방법을 사용.
	 
	 
	 [1] 하드웨어적 방법 - 인터럽트 서비스 금지

	  - 임계구역으로 진입할 때 entry 코드에서 인터럽트 서비스를 금지하고 exit 코드에서 인터럽트 서비스를 허용하는 방법
	  - 이렇게 하면 임계구역을 실행하고 있는 동안 인터럽트가 발생하지 않아 스레드는 선점되지 않는다.

	  - 아예 컴퓨터 시스템에 있는 모든 입출력 장치와 타이머가 인터럽트를 걸지 않도록 하면 상호배제는 되겠지만, 현실적으로 불가능.
	  - 그렇다면 입출력 장치나 타이머가 인터럽트를 걸 수 있도록 허용해놓고, 임계구역을 실행하는 동안만 CPU가
	     인터럽트 서비스를 하지 않도록 하고, 임계구역을 벗어난 다음 인터럽트를 서비스하도록 하는 방법.
		  -> 문제점 두가지) 
		  1. 임계구역 실행하는 동안 모든 인터럽트가 무시되는 점. 혹시라도 임계구역의 실행 시간이 길어지면
		              중요한 인터럽트의 서비스 루틴이 제때 실행되지 못할 수 있다.
		  2. 인터럽트 서비스를 금지하는 방법은 단일 CPU 시스템에서는 활용 가능하지만, 멀티코어를 비롯한
			  다중 CPU를 가진 시스템에서는 활용할 수 없다.
			-> 하나의 임계구역을 공유하는 두 스레드가 서로 다른 코어에서 실행될 때, 한 스레드가 인터럽트 서비스를
				 금지한다고 하더라도 다른 코어의 인터럽트 서비스까지 금지시키지는 못하기 때문임.
	 
	 [2] 하드웨어적 방법 - 원자 명령 (atomic instruction)

	  - 인터럽트 금지시키는 상호배제 방법은 불완전하기 때문에 오늘날 상호배제를 구현하기 위해 원자명령을 이용함.
	  - 원자명령은 상호배제를 위해 만들어진 CPU 명령이며, CPU마다 명령이 서로 다르지만 통일하여 원자명령이라 부른다.

	  [원자명령 없이 상호배제가 근본적으로 불가능한 이유]

	   1. 원자명령 없이 lock 변수를 이용한 상호배제 시도
	     
		 - lock 변수 0과 1값을 가지며, 임계구역에 들어갈때 1로 변경하고 들어가고 나오면 0으로 변경
		 - 임계구역은 lock 변수가 0일때만 들어갈 수 있음.

		 {
		 l1:
		    mov ax, lock			// lock 변수의 값 읽어 레지스터에 저장
			mov lock, 1				// lock변수에 1 저장
			cmp ax, 0				// ax레지스터 값이랑 0이랑 같은지 비교
			jump if not equal l1	// 같으면 통과 다르면 l1으로 이동

			----------------
				임계구역
			----------------
			
			mov lock 0 //lock변수에 0 저장

		} 

		문제점)
		1. t1스레드가 mov ax, lock 까지 실행하여 ax레지스터에 0을 저장하고 컨텍스트 스위칭이 되고,
		2. t2스레드가 ax에 lock(0)을 저장 후, lock에 1을 저장 후, 임계구역 통과하여 임계구역 실행 도중 스위칭되면
		3. t1은 이제 lock에 1을 넣고, ax레지스터와 0을 비교하여 진입해도되는지 보지만, 아까 ax에 0을 넣어놨기 때문에 
		    임계구역 그대로 진입하여 t1과 t2가 동시에 임계구역에서 공유자원을 건드리는 상황이 생김.

		원인) mov ax, lock 과 mov lock, 1이 동시에 실행되어야 lock변수가 동시에 0이되는 상황이 발생하지 않는다.

		해결 방법 ) 원자 명령 도입

		- 이 문제의 해결 방법은 lock값을 읽어 들이는 명령과 lock 변수에 1을 저장하는 명령 사이에 
		   컨텍스트 스위칭이 일어나지 않도록 이 두 명령을 하나의 명령으로 만드는 것이다.
		    이를 원자 명령 또는 TSL(Test ans Set Lock) 명령이라고 부른다.

		 ->	[mov ax, lock & mov lock, 1] -> [TSL ax, lock] (하드웨어적 단일 명령)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//========================  [ 멀티스레드 동기화 기법 ] ======================================//

    - 상호배제의 기반 위에, 여러 스레드들이 문제없이 공유 자원을 활용하도록 돕는 멀티스레드 동기화 기법들 소개.
	- 동기화 기법들은 겉으로 드러나지는 않지만, 임계구역에 진입할 때 상호배제를 위해 원자명령을 사용한다.

	  -> 락(lock) 방식 - 뮤텍스 (mutex) , 스핀락 (spinlock) : 락 변수를 두고, 락을 잠근 스레드만 진입
	  -> wait-signal 방식 - 세마포 (semaphore) : 여러개의 공유 자원을 여러 스레드가 사용할 수 있도록 관리.


	[1] 뮤텍스 (락걸고 나머진 큐에 대기)
	 - 뮤텍스는 잠김(locked) / 열림 (unlocked) 중 한 상태를 가지는 락 변수를 이용하여, 한 스레드만 임계구역에
	    진입시키고 다른 스레드들을 큐에 대기시키는 기법이다.

	  * 구성) 변수(락 변수) , 연산 (lock/unlock 연산) , 큐 (대기 큐)

	  1. 락 변수
	   - 락 변수를 잠김으로 만든 스레드만이 임계구역을 실행할 수 있다.
	  
	  2. lock/unlock 연산 (원자명령 기반 연산)
	   - lock 연산은 스레드가 임계구역에 들어가기 전 실행하는 entry 코드로서 락이 잠겨 있으면 현재 
	      스레드를 blocked 상태로 만들어 대기 큐에 삽입한다.
	   - 락이 열린 상태이면 락을 잠그고 임계구역으로 진입하게 한다.
	   - unlock 연산은 임게구역을 나올 때 실행하는 exit 코드로서, 락을 열림 상태로 바꾸고 대기 큐에
	     있는 스레드 하나를 깨워 준비 상태로 만든다.
	   -> lock과 unlock 연산의 구현에 원자명령이 사용됨

	  3. 뮤텍스의 특징 
	    - 임계구역의 실행 시간이 짧은 경우 뮤텍스는 비효율적이다.
		- 락이 잠겨 있는 시간보다 스레드가 잠자고 깨는데 걸리는 시간 낭비가 (컨텍스트 스위칭 시간) 더 크기 때문





------------------------------------------------

	[2] 스핀락 (spinlock) - 열릴때까지 무한 검사
	 - 스핀락도 뮤텍스와 같이 락을 기반으로 하지만, 뮤텍스와 달리 대기 큐가 없다.
	 - 락을 소유한 스레드도 타임슬라이스를 다 쓰면 스위칭되지만, 락은 해당 스레드가 소유하므로 나머지
	    스레드는 CPU를 확보하여 타임슬라이스 소진시, 락 상태 확인하다 스위칭됨 -> 결국 락 소유 스레드 락 풀때까지
	 * 구성) 변수 (락 변수) , 연산 (lock/unlock 연산)

	 1. 락 변수
	  - 스핀락 기법에서 락 변수를 간단히 스핀락이라고 부르며, 스핀락을 소유한 한개의 스레드만 임계구역에 진입할 수 있음.

	 2. lock/unlock 연산 (원자 명령 기반 구현)
	  - lock 연산은 스레드가 임계구역에 들어가기 전 실행하는 entry 코드이다.
	  - lock 연산은 락 변수가 열림 상태이면 잠김 상태로 만들고 스레드가 임계구역에 들어가게 된다.
	  - 중요!) 만일 락이 잠겨 있으면 열릴 때까지 락 검사를 무한 반복하고, 열리면 즉각 락을 잠그고 임계구역 진입
	  - unlock 연산은 락을 열림으로 변경한다. 
	  
	  -> 스핀락 기법에서 lock 연산은 락이 잠겨 있으면 무한 루프를 돌면서 락이 풀릴 때까지 검사한다.
	      결국 타임 슬라이스(락 검사 위한 타임슬라이스 CPU 할당 시간)가 소진될 때 스레드는 컨텍스트 
		  스위칭 되고, 다시 스케줄되면 다시 락이 풀릴 때까지 검사를 반복한다.

	 3. 스핀락 특징
	  1) 스핀락은 뮤텍스 기법의 바쁜 대기(busy-waiting) 모형이다.
	     -> lock 연산에서 락이 잠겨 있을 때 블록되지 않고 락이 열릴 때까지 락을 검사하는 코드를 실행하기 때문.

      2) 단일 CPU를 가진 운영체제에서 스핀락은 매우 비효율적이다. 
	     -> 단일 CPU는 바쁜 대기중인 스레드의 타임슬라이스 동안 의미없는 검사를 하는동안 다른 스레드가
		     락 소유한 상태로 CPU를 이용못하므로 락을 푸는 시간이 지연됨.
	  
	  3) 스핀락은 임계구역 코드가 짧아서 락이 빨리 열리는 응용에 매우 효과적이다. [중요!!!!]
	     -> 뮤텍스의 경우 락이 잠겨 있으면 스레드는 컨텍스트 스위칭되어 대기 큐에 들어가고, 락이 
		     열리면 다시 대기 큐에서 깨고 컨텍스트 스위칭되어 임계구역 진입한다. (2번의 컨텍스트 스위칭)
		 -> 스핀락의 의도 : 만일 이 시간보다 락이 열리는 시간이 더 짧다면 대기 큐에 들어가지 않고 락을 계속 검사하는 편이 낫다.
		 -> 스핀락을 이용하면 2번의 컨텍스트 스위칭 (락을 얻지 못한 스레드를 블록시키는, 대기 큐에서 다시 실행시키는 스위칭)
		     이 필요없고 이 사이에서 벌어지는 스케줄링 또한 필요 없다.
	 
	  4) 스핀락은 스레드들이 락을 얻기 위해 무한 경쟁하기 때문에, 불행하게도 어떤 스레드는 오랜동안
		     락을 얻지 못해 기아가 발생할 수 있다. 
		 -> 또한, 락을 잠근 스레드가 락을 열어놓지 않고 종료하거나, 잘못 코딩하여 무한 루프를 도는 경우,
		     나머지는 락이 열리기를 무한정 대기하며 CPU를 사용한다.



	[뮤텍스와 스핀락 차이 - 컨텍스트 스위칭]
	- 뮤텍스는 락이 잡혀 있으면 다른 스레드는 곧바로 block 상태로 빠지고 → 컨텍스트 스위칭 발생 (비용 O)

    - 반면 스핀락은 락이 잡혀 있어도 현재 CPU를 계속 점유하면서 무한 루프 돌고, 
	   타임슬라이스가 끝날 때까지는 스위칭 안 일어나서 → 컨텍스트 스위칭 최소화 설계

	-----
	- 뮤텍스는 임계구역이 짧을 때 비효율적이다. 락이 잡혀 있으면 다른 스레드는 OS에 의해 block상태로 전환되는데,
	   임계구역이 짧으면 자주 컨텍스트 스위칭과 커널 진입 비용이 발생한다.
	- 반면 스핀락은 대기 중이던 스레드가 풀리는 순간을 감지해서 해당 타임슬라이스 내에 처리 가능성 있으며, 
	   따로 스케줄링 없이 락 획득이 가능.


















//========================  [ 공유데이터 정의 ] ======================================//
																																																																										/*
		[==================[강의 내용]=====================]
																																																																											*/
int counter = 0;

void increment() {
	for (int i = 0; i < 10000; ++i) {
		++counter; // 공유 데이터에 접근
	}
}
																																																																											/*
	[공유 데이터 문제]

 - 멀티스레딩 환경에서는 동시에 읽고 쓰는 작업(read/write) 이 충돌(Race Condition) 을 일으킬 수 있습니다.

 - 두 스레드가 동시에 ++counter를 호출하면, 내부적으로는 다음과 같이 동작합니다
	
	1. 레지스터에 counter 값 로드
	2. +1 수행
	3. 결과를 메모리에 저장
 
 -	이 사이에 다른 스레드가 counter 값을 변경하면, 값이 덮어쓰기 되어 의도한 결과보다 적게 증가할 수 있습니다. 이게 데이터 경쟁(Race Condition) 입니다.

 [ 동기화(Synchronization)란? ]
 - 스레드 동기화는 여러 스레드가 동시에 접근하는 자원(공유 데이터, 장치 등) 에 대해 정해진 순서나 일관된 결과를 보장하도록 접근을 조정하는 것.
 1. mutex (뮤텍스)
 2. lock_guard
 3. atomic
 4. condition_variable


*/

