																																																																																																																																																																																														/*



      1. 페이징 메모리 관리 개요

	  [페이징 개념]

	 - 페이징은 프로세스의 주소 공간을 0번지부터 페이지로 불리는 고정 크기로 나누고 물리
	   메모리 역시 0번지부터 페이지와 동일한 크기로 분할하여, 프로세스의 각 페이지를 물리
	    메모리의 임의의 페이지에 분산 할당하는 메모리 관리 기법이다.
	 
	 - 물리 메모리에서 페이지 크기의 메모리 블록을 프레임(frame), 페이지 프레임 (page frame), 혹은
	    물리 페이지 (physical frame)이라고 부른다.
	 - 페이지는 대부분 4KB로 설정되지만, 시스템에 따라 8KB, 16KB로 설정되기도 함.

	 - 페이징 기법의 기본 이론은 프로세스의 주소 공간을 페이지 크기로 일률적으로 나누고 페이지 경계를 고려하지
	    않고 코드, 데이터, 힙을 연이어 배치한다.
	 - 그러므로 코드가 담긴 마지막 페이지에 데이터 영역이 시작되고 데이터 영역의 마지막 페이지 내에
	    힙 영역이 시작된다.
	 - 하지만, 실제 운영체제들은 코드, 데이터, 힙 등을 쉽게 관리하기 위해 데이터와 힙 영역이 새 페이지에서
	    시작하도록 배치한다.

	 - 물리 메모리가 프레임으로 분할되어 있고, 프로세스의 각 페이지가 페이지 테이블을 통해 물리 프레임에
	    매핑된다.
	 - 프로세스마다 페이지와 물리 프레임을 매핑하는 페이지 테이블이 존재하며, MMU 장치는 페이지 테이블을
	    이용하여 논리주소를 물리주소로 변환한다.

	 [페이지 우수성]

	  1) 구현이 쉽다
	   - 페이징은 메모리를 0번지부터 고정 크기의 페이지로 분할하기 때문에 세그먼테이션보다 이해하기 쉽고 구현하기 쉬움.
	  
	  2) 이식성이 높다(portable)
	   - 페이징은 CPU에 의존적이지 않기 때문에 다양한 컴퓨터 시스템에 동일한 방식으로 쉽게 구현 가능.

	  3) 융통성이 높다 (flexible)
	   - 시스템에 따라 혹은 응용에 따라 페이지 크기를 다르게 설정할 수 있다.
	   
	  4) 단편화
	   - 세그먼테이션에서 발생하는 외부 단편화가 없고, 홀 선택 알고리즘을 실행할 필요가 없어,
	      메모리 활용과 시간 오버헤드 면에서 훨씬 우수하다.
	   - 물론 내부 단편화가 발생하지만, 그 크기는 매우 작다.


	 [프로세스가 동적 할당 받을 때]

	  - 프로세스의 힙과 스택 영역은 프로세스의 실행 중에 피에지가 생기기도 하고 소멸되기도 하면서 계속 변한다.
	  - char* a = new char[200];
	  - 운영체제는 new char[200] 함수가 요청한 200바이트의 메모리를 할당하기 위해 먼저 프로세스의 힙 영역에
	     페이지를 할당(전 페이지를 모두 사용한 가정)
	  - 비어 있는 물리 프레임을 할당하여 프로세스 페이지 테이블의 항목에 프레임 번호를 기록하여 연결해줌.
	  - 이러면 *a를 하면 할당 받은 페이지에 기록하는데 CPU는 논리주소에 접근하는것 같지만, 실제로는
	     MMU에 의해 논리주소가 물리주소로(페이지 테이블을 거쳐) 변환하여 해당 물리 주소에 저장.

	 [시스템 호출시 프로세스의 페이지 테이블 활용]

	  - 프로세스 주소 공간 중 커널 페이지들을 물리 프레임에 매핑하는 프로세스 테이블 항목들도 존재한다.
	  - 프로세스 주소 공간에서 커널 페이지가 활용되는 경우는 프로세스가 시스템 호출을 하는 경우이다.
	  - 커널 코드 역시 논리 주소로 컴파일되어 있으며, 시스템 호출을 통해 커널 코드가 실행될 때
	    현재 프로세스의 페이지 테이블을 이용하여 물리 주소로 변환된다.
      - 커널도 논리 주소 기반 컴파일이어서 다른 프로세스가 같은 커널 코드를 호출할 때, 
	     결론적으로 페이지 테이블을 거쳐 같은 물리 주소의 커널 코드를 실행.
	  - 커널 코드는 단 하나의 물리 메모리 공간에 존재하기 때문.


	  2. 페이징의 주소 체계

	 [페이징의 논리 주소]

	  - 페이징을 사용하는 시스템에서는 프로세스의 논리 주소는 다음과 같이 페이지 번호와 옵셋으로 구성됨.
	  - 옵셋은 페이지 내에서의 상대 주소이고, 몇번째 바이트인지.
	  [논리주소] : [페이지 번호(p) , 옵셋(offset)]

	 [논리 주소의 물리 주소 변환]

	  - 페이지 테이블에는 프로세스의 모든 페이지에 대해 할당된 프레임 번호가 저장되기 때문에
	     특정 페이지를 페이지 테이블의 인덱스로 하여 페이지 테이블 항목을 찾으면 대응하는 프레임 번호를
		  얻음.
	  - 페이지 번호를 프레임 번호로 바꾸고, 옵셋을 그대로 사용하면 논리 주소를 물리 주소로 변환가능
	  -> 옵셋은 그대로 사용하는 이유는 논리 페이지나 물리 페이지 크기가 같으므로.
	  - 페이지 테이블도 물리 메모리에 저장되긴함.

	 [페이징 구현]

	  1) 하드웨어 지원
	   - PCU 칩 내에는 현재 실행중인 프로세스의 페이지 테이블이 적재된 물리 메모리 주소를 가진 레지스터,
	      PTBR(Page Table Base Register)이 필요하다.
	   - 이 레지스터의 값은 PCB에 저장되며, 프로세스가 스케줄되어 실행될 때 운영체제에 의해 CPU에 복귀한다.
	   - 또한 논리 주소를 물리 주소로 변환하기 위한 MMU 장치가 CPU칩에 패키징됨.

	  2) 운영체제 지원
	   - 운영체제는 물리 메모리의 빈 프레임 리스트를 생성하고 관리 유지하며, 메모리 프레임을 동적으로
	      할당/반환하는 기능과 이에 따라 페이지 테이블을 관리하는 기능을 가지고 있어야 한다.
	   - 또한 각 프로세스마다 페이지 테이블이 적재된 물리 메모리 주소를 PCB에 저장하고 프로세스가 스케줄되어
	      실행될 때마다 PCB로부터 페이지 테이블의 물리 주소를 CPU 내 PTBR 레지스터로 옮겨야 한다.
		  ~pg430




















































































																																																																																																																																											*/